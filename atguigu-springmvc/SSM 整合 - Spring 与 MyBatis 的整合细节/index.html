<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>SSM 整合 - Spring 与 MyBatis 的整合细节 | RQTN</title><meta name="author" content="RQTN"><meta name="copyright" content="RQTN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SSM 整合 - Spring 与 MyBatis 的整合细节先列出 Spring 与 Mybatis 整合后，Spring 的配置文件内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;U">
<meta property="og:type" content="article">
<meta property="og:title" content="SSM 整合 - Spring 与 MyBatis 的整合细节">
<meta property="og:url" content="http://example.com/atguigu-springmvc/SSM%20%E6%95%B4%E5%90%88%20-%20Spring%20%E4%B8%8E%20MyBatis%20%E7%9A%84%E6%95%B4%E5%90%88%E7%BB%86%E8%8A%82/index.html">
<meta property="og:site_name" content="RQTN">
<meta property="og:description" content="SSM 整合 - Spring 与 MyBatis 的整合细节先列出 Spring 与 Mybatis 整合后，Spring 的配置文件内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;U">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2022-12-05T13:30:36.000Z">
<meta property="article:modified_time" content="2024-04-01T02:52:42.473Z">
<meta property="article:author" content="RQTN">
<meta property="article:tag" content="atguigu-springmvc">
<meta property="article:tag" content="Mybatis 接口代理机制">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/atguigu-springmvc/SSM%20%E6%95%B4%E5%90%88%20-%20Spring%20%E4%B8%8E%20MyBatis%20%E7%9A%84%E6%95%B4%E5%90%88%E7%BB%86%E8%8A%82/index.html"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: RQTN","link":"链接: ","source":"来源: RQTN","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SSM 整合 - Spring 与 MyBatis 的整合细节',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-01 10:52:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index_img_cut.png')"><nav id="nav"><span id="blog-info"><a href="/" title="RQTN"><span class="site-name">RQTN</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SSM 整合 - Spring 与 MyBatis 的整合细节</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-12-05T13:30:36.000Z" title="发表于 2022-12-05 21:30:36">2022-12-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/SpringMVC/">SpringMVC</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/Mybatis/">Mybatis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SSM 整合 - Spring 与 MyBatis 的整合细节"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="SSM-整合-Spring-与-MyBatis-的整合细节"><a href="#SSM-整合-Spring-与-MyBatis-的整合细节" class="headerlink" title="SSM 整合 - Spring 与 MyBatis 的整合细节"></a>SSM 整合 - Spring 与 MyBatis 的整合细节</h2><p>先列出 Spring 与 Mybatis 整合后，Spring 的配置文件内容：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.powernode.bank&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--引入外部的属性配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册 SqlSessionFactoryBean：通过该 Bean 获取 SqlSessionFactory 核心对象，从而再获取 SqlSession 对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置 Mybatis 核心配置文件路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置包别名--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.powernode.bank.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注册 Mapper 扫描配置器：指定扫描的包路径，为包下所有的 mapper 接口，动态生成接口代理类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.powernode.bank.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启事务注解驱动器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="细节一：SqlSessionFactoryBean-是如何完成配置转移的"><a href="#细节一：SqlSessionFactoryBean-是如何完成配置转移的" class="headerlink" title="细节一：SqlSessionFactoryBean 是如何完成配置转移的"></a>细节一：<code>SqlSessionFactoryBean</code> 是如何完成配置转移的</h3><p>Spring 与 MyBatis 集成后，MyBatis 核心配置文件中绝大多数的配置，都可以很方便地转移到 Spring 的配置文件中来。具体是怎么完成转移的呢？关键就在于，新加入的依赖 <code>mybatis-spring</code> 中提供了一个功能强大的 <code>SqlSessionFactoryBean</code>。</p>
<p>回忆 Mybatis 的内容，我们提供 Mybatis 的配置文件，其实就是要根据该配置文件的内容，去创建 <code>SqlSessionFactory</code> 对象，然后再从中获取 <code>SqlSession</code> 对象来操作数据库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsReader(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(is);</span><br><span class="line">sqlSession = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure>
<p>转换到 Spring 的语境下，其实就是要在 IoC 容器中注册一个 <code>SqlSessionFactory</code> 对象。因此 <code>mybatis-spring</code> 就直接提供了一个工厂 Bean 对象 <code>SqlSessionFactoryBean</code>，用于辅助 Spring 创建 <code>SqlSessionFactory</code> 对象。</p>
<p><code>SqlSessionFactoryBean</code> 提供了非常多的属性来帮助我们转移 MyBatis 核心配置文件中的配置。</p>
<p>比如 MyBatis 配置文件中的 <code>&lt;environment&gt;</code> 标签下的 <code>&lt;dataSource&gt;</code> 标签配置，就对应了 <code>SqlSessionFactoryBean</code> 的 <code>dataSource</code> 属性：在 Spring 配置文件下，我们可以先声明一个数据源如 <code>DruidDataSource</code>，然后注入到 <code>SqlSessionFactoryBean</code> 的 <code>dataSource</code> 属性中。</p>
<h3 id="细节二：-lt-transactionManager-type-quot-JDBC-quot-gt-的底层原理"><a href="#细节二：-lt-transactionManager-type-quot-JDBC-quot-gt-的底层原理" class="headerlink" title="细节二：&lt;transactionManager type=&quot;JDBC&quot;/&gt; 的底层原理"></a>细节二：<code>&lt;transactionManager type=&quot;JDBC&quot;/&gt;</code> 的底层原理</h3><p><code>&lt;transactionManager&gt;</code> 用于配置 Mybatis 的事务管理器，属性 <code>type</code> 有两个可选值：<code>JDBC</code> 和 <code>MANAGED</code>。</p>
<ul>
<li><p>如果 <code>type</code> 为 <code>JDBC</code> 的话，那么所构建的 <code>SqlSessionFacory</code> 对象中所采用的 <code>TransactionFactory</code> 就是 <code>JdbcTransactionFactory</code>，创建出来的 <code>SqlSession</code> 底层采用的就是 <code>JdbcTransaction</code> 来管理事务。</p>
</li>
<li><p>如果 <code>type</code> 为 <code>MANAGED</code> 的话，那么所构建的 <code>SqlSessionFacory</code> 对象中所采用的 <code>TransactionFactory</code> 就是 <code>ManagedTransactionFactory</code>，创建出来的 <code>SqlSession</code> 底层采用的就是 <code>ManagedTransaction</code> 来管理事务。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SqlSessionFactoryBuilder</span></span><br><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> &#123;</span><br><span class="line">    <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(reader, environment, properties);</span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XMLConfigBuilder</span></span><br><span class="line"><span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XMLConfigBuilder</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XMLConfigBuilder</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">TransactionFactory</span> <span class="variable">txFactory</span> <span class="operator">=</span> transactionManagerElement(child.evalNode(<span class="string">&quot;transactionManager&quot;</span>));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XMLConfigBuilder</span></span><br><span class="line"><span class="keyword">private</span> TransactionFactory <span class="title function_">transactionManagerElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">      <span class="type">TransactionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (TransactionFactory) resolveClass(type).getDeclaredConstructor().newInstance();</span><br><span class="line">      <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看到，Mybatis 的事务管理器，其实指的是 <code>SqlSessionFactory</code> 所采用的事务工厂 <code>TransactionFactory</code>。</p>
<h3 id="细节三：MapperScannerConfigurer-的底层原理"><a href="#细节三：MapperScannerConfigurer-的底层原理" class="headerlink" title="细节三：MapperScannerConfigurer 的底层原理"></a>细节三：<code>MapperScannerConfigurer</code> 的底层原理</h3><p>回顾之前学习 Mybatis 的时候，我们是使用 <code>sqlSession.getMapper(AccountMapper.class)</code> 来获取接口的动态代理的。</p>
<p>而在 Spring + Mybatis 的整合场景下，我们没有显示地去编写 <code>sqlSession.getMapper</code> 的代码，而是通过在 Spring 配置文件中配置了一个 <code>MapperScannerConfigurer</code> 接口扫描配置器，让该配置器为我们生成接口代理并注册到 Spring IoC 容器中去。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.powernode.bank.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面将深入源码，说明 <code>MapperScannerConfigurer</code> 的底层的执行过程。</p>
<h4 id="了解-BeanDefinitionRegistryPostProcessor-接口原理"><a href="#了解-BeanDefinitionRegistryPostProcessor-接口原理" class="headerlink" title="了解 BeanDefinitionRegistryPostProcessor 接口原理"></a>了解 <code>BeanDefinitionRegistryPostProcessor</code> 接口原理</h4><p>我们先来关注 <code>MapperScannerConfigurer</code> 所实现的 <code>BeanDefinitionRegistryPostProcessor</code> 接口。</p>
<p><code>BeanDefinitionRegistryPostProcessor</code> 接口的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanDefinitionRegistryPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeansException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口中的 <code>postProcessBeanDefinitionRegistry</code> 方法是 Spring 框架所提供的一个扩展点：在所有的 <code>BeanDefinition</code> 注册到 Spring 以后，在 Spring 根据这些 <code>BeanDefinition</code> 来进行实例化以前，Spring 会调用这个方法，并传入保存了当前所有 <code>BeanDefinition</code> 的 <code>BeanDefinitionRegistry</code>。</p>
<p>所以，如果你希望在所有的 <code>BeanDefinition</code> 完成注册之后，先对这些 <code>BeanDefinition</code> 做一些修改和调整，然后再让 Spring 去根据这些 <code>BeanDefinition</code> 去实例化 Bean，那么你就可以定义一个类，让这个类实现 <code>BeanDefinitionRegistryPostProcessor</code> 接口中的 <code>postProcessBeanDefinitionRegistry</code> 方法，在方法中进行 <code>BeanDefinition</code> 的修改和调整，最后再将该类声明到 Spring 配置文件中。</p>
<p><code>BeanDefinition</code> 其实就是 Bean 定义信息，可以将其理解为 Spring 配置文件中的 Bean 标签对应的配置信息封装类，其中包含了 Bean 的对应的 Class 对象，以及要注入的属性等信息。</p>
<p>如果在 <code>postProcessBeanDefinitionRegistry</code> 方法中修改了 <code>BeanDefinition</code> 关联的 Class 对象，比如从 <code>A.class</code> 修改为 <code>B.class</code>，那么 Spring 根据修改后的 <code>BeanDefinition</code> 实例化得到的是 <code>B</code> 对象而非 <code>A</code> 对象。这一点是我们后面将 Mapper 接口改造为 <code>MapperFactoryBean</code> 的关键。</p>
<p><code>BeanDefinitionRegistry</code> 其实就是 Bean 定义信息注册中心，Spring 容器在初始化时，会读取配置文件中所有的 Bean 标签，对于每个 Bean 标签，封装为对应的一个 <code>BeanDefinition</code> 然后注册到 <code>BeanDefinitionRegistry</code> 中。</p>
<h4 id="扫描阶段：MapperScannerConfigurer-扫描指定包下的所有-Mapper-接口，为其创建-BeanDefinition-并注册到-Spring-中"><a href="#扫描阶段：MapperScannerConfigurer-扫描指定包下的所有-Mapper-接口，为其创建-BeanDefinition-并注册到-Spring-中" class="headerlink" title="扫描阶段：MapperScannerConfigurer 扫描指定包下的所有 Mapper 接口，为其创建 BeanDefinition 并注册到 Spring 中"></a>扫描阶段：<code>MapperScannerConfigurer</code> 扫描指定包下的所有 Mapper 接口，为其创建 <code>BeanDefinition</code> 并注册到 Spring 中</h4><p><code>MapperScannerConfigurer</code> 实现了 <code>BeanDefinitionRegistryPostProcessor</code> 接口，并在声明到了 Spring 配置文件中。</p>
<p>所以当所有的 <code>BeanDefinition</code> 注册到 Spring 容器的 <code>BeanDefinitionRegistry</code> 以后，会调用 <code>MapperScannerConfigurer</code> 所实现的接口方法 <code>postProcessBeanDefinitionRegistry</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperScannerConfigurer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建类路径 Mapper 扫描器，并初始化扫描器的一些参数</span></span><br><span class="line">    <span class="type">ClassPathMapperScanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathMapperScanner</span>(registry);</span><br><span class="line">    <span class="comment">// 其中一个比较重要的扫描器参数的初始化</span></span><br><span class="line">    scanner.setMapperFactoryBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">    <span class="comment">// 扫描指定的 basePackage 包，对读到的每个 Mapper 接口做一些处理</span></span><br><span class="line">    scanner.scan(</span><br><span class="line">        StringUtils.tokenizeToStringArray(<span class="built_in">this</span>.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看方法的参数，Spring 调用该方法时传入的 <code>registry</code> 参数保存了当前所有已注册的 <code>BeanDefinition</code>，此时打断点可以看到，目前 <code>registry</code> 中还不包含 Mapper 接口相关的 <code>BeanDefiniton</code>。</p>
<p>方法内部首先创建了一个 Mapper 扫描器，并使用 <code>MapperScannerConfigurer</code> 类内部的成员变量，对该扫描器的一些参数进行初始化。</p>
<p>在 Spring 配置文件中声明 <code>MapperScannerConfigurer</code> 时，我们并没有为其 <code>mapperFactoryBeanClass</code> 属性提供值，该属性也没有默认初始化，所以 <code>this.mapperFactoryBeanClass</code> 为 <code>null</code>，此时 <code>scanner</code> 就会使用一个默认的 Class 对象 <code>MapperFactoryBean.class</code> 来对内部的 <code>mapperFactoryBeanClass</code> 属性进行赋值，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMapperFactoryBeanClass</span><span class="params">(Class&lt;? extends MapperFactoryBean&gt; mapperFactoryBeanClass)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.mapperFactoryBeanClass = mapperFactoryBeanClass == <span class="literal">null</span> ? MapperFactoryBean.class : mapperFactoryBeanClass;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>扫描器创建并初始化配置完成后，就开始进行扫描了。Mapper 接口的扫描逻辑在 <code>scanner.scan</code> 方法中，打开该方法，发现主要的逻辑，有都放在了 <code>doScan</code> 方法内。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 Mapper 扫描前，已经注册的 BeanDefinition 的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">beanCountAtScanStart</span> <span class="operator">=</span> <span class="built_in">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 完成包扫描，其中会注册一些与 Mapper 接口相关的新的 BeanDefinition</span></span><br><span class="line">    doScan(basePackages);</span><br><span class="line">    <span class="comment">// 返回一个新注册的 BeanDefinition 的数量</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看 <code>doScan</code> 方法，该方法主要分为两步：</p>
<ul>
<li><p>第一步：先扫描指定 <code>basePackage</code> 及其子包下的所有 Mapper 接口，为每个 Mapper 接口创建一个 <code>BeanDefinition</code> 对象，并注册到 Spring 中。<br>假设 <code>basePackage</code> 下有一个 <code>AccountMapper</code> 接口，那么 <code>super.doScan()</code> 执行完以后，Spring 的 <code>BeanDefinitionRegistry</code> 中包含一个新的 <code>BeanDefinition</code>，其名字为 <code>accountMapper</code>，其对应的 Class 对象为 <code>AccountMapper.class</code>。</p>
</li>
<li><p>第二步：每个 Mapper 接口本身作为接口，是无法实例化的，因此需要经过 <code>processBeanDefinitions()</code> 方法对每个 Mapper 接口对应的 <code>BeanDefinition</code> 进行调整。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">doScan</span><span class="params">(String... basePackages)</span> &#123;</span><br><span class="line">    <span class="comment">// 扫描指定包下的所有 Mapper 接口，并创建相应 BeanDefinition 注册到 Spring 中</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="built_in">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有 Mapper 接口创建了相应的 BeanDefinition，就对这些 BeanDefinition 进行调整。</span></span><br><span class="line">    <span class="keyword">if</span> (!beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      processBeanDefinitions(beanDefinitions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="调整-修改阶段：MapperScannerConfigurer-对新创建-BeanDefinition-进行调整，确保-Spring-根据调整后的-BeanDefinition-所实例化的是一个-MapperFactoryBean-对象"><a href="#调整-修改阶段：MapperScannerConfigurer-对新创建-BeanDefinition-进行调整，确保-Spring-根据调整后的-BeanDefinition-所实例化的是一个-MapperFactoryBean-对象" class="headerlink" title="调整/修改阶段：MapperScannerConfigurer 对新创建 BeanDefinition 进行调整，确保 Spring 根据调整后的 BeanDefinition 所实例化的是一个 MapperFactoryBean 对象"></a>调整/修改阶段：<code>MapperScannerConfigurer</code> 对新创建 <code>BeanDefinition</code> 进行调整，确保 Spring 根据调整后的 <code>BeanDefinition</code> 所实例化的是一个 <code>MapperFactoryBean</code> 对象</h4><p><code>processBeanDefinitions</code> 方法内部具体是怎么调整的呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> &#123;</span><br><span class="line">    <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> getRegistry();</span><br><span class="line">    <span class="comment">// 遍历每个 Mapper 接口对应的 BeanDefinition，对其进行调整</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">        definition = (AbstractBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">        <span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> definition.getBeanClassName();</span><br><span class="line">        <span class="comment">// 调整一：添加一个初始化实参值，值为相应 Mapper 接口的全类名</span></span><br><span class="line">        definition.getConstructorArgumentValues().addGenericArgumentValue(beanClassName);</span><br><span class="line">        <span class="comment">// 调整二：修改 `BeanDefinition` 关联的 Class 对象为 MapperFactoryBean.class</span></span><br><span class="line">        definition.setBeanClass(<span class="built_in">this</span>.mapperFactoryBeanClass);</span><br><span class="line">        <span class="comment">// 调整三：将 `BeanDefinition` 的装配模式设置为按类型自动装配</span></span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设我们正在调整的是 <code>AccountMapper</code> 对应的 <code>BeanDefinition</code>。</p>
<ul>
<li>我们先来看调整二，这一步是最关键的一步。</li>
</ul>
<p>调整前，<code>BeanDefinition</code> 中所关联的 Class 对象是接口 Class 对象 <code>AccountMapper.class</code>，接口 Class 显然是无法进行实例化的，所以修改为 <code>MapperFactoryBean.class</code>。这样后续 Spring 在根据调整后的 <code>BeanDefinition</code> 进行实例化时，创建的就是 <code>MapperFactoryBean</code> 对象了。</p>
<p><code>MapperFactoryBean</code> 是一个实现了 <code>FactoryBean</code> 接口的工厂 Bean 对象，其内部有一个非常重要的 <code>mapperInterface</code> 属性，该属性绑定了某个 Mapper 接口的 Class 对象比如 <code>AccountMapper.class</code>，后续将会以构造注入的方式赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapperFactoryBean</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MapperFactoryBean</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>MapperFactoryBean</code> 的 <code>getObject</code> 方法就是为内部绑定的 Mapper 接口生成相应的接口代理。</p>
<ul>
<li>我们再来看调整一，这一步主要是提供 <code>MapperFactoryBean</code> 中 <code>mapperInterface</code> 属性的初始化参数，方便对其进行构造注入。</li>
</ul>
<p>这里面有个小细节要说明一下，<code>MapperFactoryBean</code> 中的 <code>mapperInterface</code> 是 Class 类型，但是我们在调整一中所设置的初始化参数，却是有个全类名字符串，比如 <code>com.powernode.bank.mapper.AccountMapper</code>，这能成功注入吗？</p>
<p>答案是可以的，因为 <code>Class</code> 类型是 Spring 中的简单类型，所以直接提供全类名字符串作为 value，Spring 底层会为我们做相应的类型转换，得到全类名对应的类的 Class 对象再进行注入！</p>
<ul>
<li>我们最后来看调整三，这一步确保 <code>MapperFactoryBean</code> 继承自父类的 <code>sqlSessionTemplate</code> 属性，后续能够通过按类型的自动装配附上值。</li>
</ul>
<p>还记得在调整一中 <code>getObject()</code> 方法内部调用的 <code>getSqlSession()</code> 吗？其实这个是父类 <code>SqlSessionDaoSupport</code> 的方法。我们来看 <code>SqlSessionDaoSupport</code> 中比较关键的部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">extends</span> <span class="title class_">DaoSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSessionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sqlSessionTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSessionFactory</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.sqlSessionTemplate == <span class="literal">null</span> || sqlSessionFactory != <span class="built_in">this</span>.sqlSessionTemplate.getSqlSessionFactory()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSessionTemplate = createSqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SqlSessionTemplate <span class="title function_">createSqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SqlSessionTemplate</span>(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>MapperFactoryBean</code> 继承了 <code>SqlSessionDaoSupport</code>，所以 <code>MapperFactoryBean</code> 类中也包含了继承自父类的 <code>setSqlSessionFactory</code> 方法。</p>
<p>在调整三处，我们将 <code>BeanDefinition</code> 的装配模式设置为按类型自动装配，这样后续 Spring 在实例化时，就会去查找 <code>MapperFactoryBean</code> 类中的所有 setter 方法并进行调用。</p>
<p>此时 <code>setSqlSessionFactory</code> 方法就得到调用，该方法根据传入的 <code>sqlSessionFactory</code>，创建一个新的 <code>SqlSessionTemplate</code> 赋值给内部的 <code>sqlSessionTemplate</code> 属性，从而 <code>getObject()</code> 方法内部调用的 <code>getSqlSession()</code> 就能获取到值了！</p>
<h4 id="从-MapperFactoryBean-到-Mapper-接口的代理类"><a href="#从-MapperFactoryBean-到-Mapper-接口的代理类" class="headerlink" title="从 MapperFactoryBean 到 Mapper 接口的代理类"></a>从 <code>MapperFactoryBean</code> 到 Mapper 接口的代理类</h4><p>当 Service 类需要注入相应的 Mapper 接口时，就会从三级缓存中找到该 Mapper 接口对应的 <code>MapperFactoryBean</code>，然后调用 <code>getObject()</code> 方法生成最终的代理类，并注入到 Service 中。</p>
<p>之前我们说过 <code>MapperFactoryBean</code> 的 <code>getObject()</code> 方法内部，依然是调用 <code>sqlSession.getMapper</code> 来生成接口代理的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MapperFactoryBean</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">return</span> getSqlSession().getMapper(<span class="built_in">this</span>.mapperInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只不过，这里 <code>getSqlSession()</code> 获取到的是 <code>SqlSessionTemplate</code> 对象，而不是之前学习 Mybatis 时的 <code>DefaultSqlSession</code> 对象。</p>
<p><code>SqlSessionTemplate</code> 是一个有趣的对象，它在整个应用中是单例存在，由于它也实现了 <code>SqlSession</code> 接口，所以可以伪装成 <code>SqlSession</code> 对象来调用 <code>getMapper</code> 方法为所有 Mybatis Mapper 接口生成代理类。</p>
<p>最后补充说明一点，虽然每个生成并注册到 Spring 中的接口代理类，其内部持有的 <code>sqlSession</code> 属性都指向 <code>SqlSessionTemplate</code> 单例，但是 <code>SqlSessionTemplate</code> 本身并没有在 Spring 容器中进行注册。</p>
<h3 id="细节四：Mybatis-的事务管理器和-Spring-的事务管理器-txManager-的关系是什么？"><a href="#细节四：Mybatis-的事务管理器和-Spring-的事务管理器-txManager-的关系是什么？" class="headerlink" title="细节四：Mybatis 的事务管理器和 Spring 的事务管理器 txManager 的关系是什么？"></a>细节四：Mybatis 的事务管理器和 Spring 的事务管理器 <code>txManager</code> 的关系是什么？</h3><p>Spring 的事务管理器是在 <code>spring-jdbc</code> 依赖中提供的，在不集成 Mybatis 的情况下，或者说世界上没有 Mybatis 框架的情况下，Spring 也有自己的事务管理器实现。</p>
<p>因此，Mybatis 的事务管理器，和 Spring 的事务管理器，其实并不是同一个东西：</p>
<ul>
<li><p>Mybatis 的事务管理器，本质上是一个是面向 <code>SqlSession</code> 的事务工厂。<br>每个 <code>SqlSession</code> 创建时，事务工厂会为其创建一个 <code>Transaction</code> 对象并放到 <code>SqlSession</code> 内部。调用 <code>sqlSession.commit()</code> 等事务方法时，底层是调用内部 <code>Transaction</code> 对象的事务方法，对 <code>Transaction</code> 对象中的 <code>Connection</code> 连接进行操作。</p>
</li>
<li><p>Spring 的事务管理器，是直接面向 <code>Connection</code> 连接对象的。</p>
</li>
</ul>
<p>Mybatis 和 Spring 的事务管理器底层一定都是对 <code>Connection</code> 对象进行事务操作。只不过 Mybatis 的事务管理器相对而言就不那么纯粹，它还附带了一些 <code>Connection</code> 对象与 <code>SqlSession</code> 对象整合的逻辑。</p>
<p>Mybatis 和 Spring 的事务管理器不是同一个东西，那在 Spring + Mybatis 的整合场景下（回顾最开始的 Spring 配置文件），这两个事务管理器分别是什么？</p>
<ul>
<li>Mybatis 的事务管理器是 <code>SpringManagedTransactionFactory</code> 事务工厂。</li>
</ul>
<p>从 <code>SqlSessionFactoryBean</code> 的内部源码可以看出这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SqlSessionFactoryBean</span></span><br><span class="line"><span class="keyword">protected</span> SqlSessionFactory <span class="title function_">buildSqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">Environment</span> <span class="variable">env</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>(</span><br><span class="line">        <span class="built_in">this</span>.environment,</span><br><span class="line">        <span class="built_in">this</span>.transactionFactory == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">SpringManagedTransactionFactory</span>() </span><br><span class="line">                                        : <span class="built_in">this</span>.transactionFactory,</span><br><span class="line">        <span class="built_in">this</span>.dataSource);</span><br><span class="line">    targetConfiguration.setEnvironment(env);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Spring 配置文件中，如果没有明确为 <code>SqlSessionFactoryBean</code> 注入 <code>transactionFactory</code> 属性，那么就会默认创建 <code>SpringManagedTransactionFactory</code> 来作为事务工厂。</p>
<p>一般来说，在 Spring + Mybatis 的整合场景下，我们不会为 <code>SqlSessionFactoryBean</code> 注入 <code>transactionFactory</code> 属性。Mybatis 中文网关于 <code>&lt;transactionManager&gt;</code> 也有相应说明：</p>
<blockquote>
<p>如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</p>
</blockquote>
<ul>
<li>Spring 的事务管理器是 <code>txManager</code>，也即 <code>DataSourceTransactionManager</code>。</li>
</ul>
<h3 id="细节五：在-Spring-声明式事务下，Spring-和-Mybatis-的两个事务管理器是如何协同工作的？"><a href="#细节五：在-Spring-声明式事务下，Spring-和-Mybatis-的两个事务管理器是如何协同工作的？" class="headerlink" title="细节五：在 Spring 声明式事务下，Spring 和 Mybatis 的两个事务管理器是如何协同工作的？"></a>细节五：在 Spring 声明式事务下，Spring 和 Mybatis 的两个事务管理器是如何协同工作的？</h3><p>Mybatis 和 Spring 的事务管理器不是同一个东西，但它们底层又都是对 <code>Connection</code> 对象进行操作，那在 Spring 声明式事务下，当一个被 <code>@Transactional</code> 标注的业务方法被调用时，这两个事务管理器是怎么协同工作的？</p>
<h4 id="第一阶段：Spring-AOP-拦截业务方法的调用，为当前线程创建并开启事务"><a href="#第一阶段：Spring-AOP-拦截业务方法的调用，为当前线程创建并开启事务" class="headerlink" title="第一阶段：Spring AOP 拦截业务方法的调用，为当前线程创建并开启事务"></a>第一阶段：Spring AOP 拦截业务方法的调用，为当前线程创建并开启事务</h4><p>当一个被 <code>@Transactional</code> 标注的业务方法被调用时，Spring AOP 首先会进行拦截，在其动态代理的增强中，使用已注册的 <code>txManager</code> 来进行事务控制：</p>
<ul>
<li>首先会尝试获取当前线程的事务，发现获取不到，于是就会去开启一个事务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractPlatformTransactionManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line">    <span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">        <span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>开启事务的主要工作是：先从数据源中获取了一个 <code>Connection</code> 对象，关闭自动提交，然后将该连接放到一个 <code>ThreadLocal</code> 中。</li>
</ul>
<p>更具体地说，从数据源中获取的 <code>Connection</code> 对象会先被封装到一个 <code>ConnectionHolder</code> 对象中，然后关闭连接的自动提交，最后将 <code>ConnectionHolder</code> 放到 <code>TransactionSynchronizationManager</code> 类中的 <code>ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources</code> 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DataSourceTransactionManager</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> &#123;</span><br><span class="line">    <span class="comment">// 事务对象</span></span><br><span class="line">    <span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果事务对象没有 ConnectionHolder</span></span><br><span class="line">    <span class="keyword">if</span> (!txObject.hasConnectionHolder()) &#123;</span><br><span class="line">        <span class="comment">// 从数据源中获取 Connection，包装为 ConnectionHolder 后放入事务对象中</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">newCon</span> <span class="operator">=</span> obtainDataSource().getConnection();</span><br><span class="line">        txObject.setConnectionHolder(<span class="keyword">new</span> <span class="title class_">ConnectionHolder</span>(newCon), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭事务对象的连接的自动提交</span></span><br><span class="line">    con = txObject.getConnectionHolder().getConnection();</span><br><span class="line">    con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 将 ConnectionHolder 绑定到 ThreadLocal 中</span></span><br><span class="line">    TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，<code>resources</code> 为线程绑定的是一个 <code>Map&lt;Object, Object&gt;</code> 集合。当前线程第一次进行绑定时，<code>resources.get()</code> 为空，因此会创建一个空的 Map 集合绑定进去。</p>
<p>然后将数据源作为 key，将 <code>ConnectionHolder</code> 作为 value，放入该 Map 集合，从而完成 <code>Connection</code> 到 <code>ThreadLocal</code> 的绑定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TransactionSynchronizationManager</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bindResource</span><span class="params">(Object key, Object value)</span> <span class="keyword">throws</span> IllegalStateException &#123;</span><br><span class="line">    Map&lt;Object, Object&gt; map = resources.get();</span><br><span class="line">    <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        resources.set(map);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经通过 Spring AOP 为当前线程创建并绑定了事务，接下来就要执行目标业务方法了，目标业务方法中就涉及到对 Mybatis 接口代理类的方法调用，如 <code>accountMapper.selectByActno(actno)</code>。</p>
<h4 id="第二阶段：Mybatis-接口代理类将-Mapper-接口方法的调用，转换为-SqlSession-数据库操作的调用。"><a href="#第二阶段：Mybatis-接口代理类将-Mapper-接口方法的调用，转换为-SqlSession-数据库操作的调用。" class="headerlink" title="第二阶段：Mybatis 接口代理类将 Mapper 接口方法的调用，转换为 SqlSession 数据库操作的调用。"></a>第二阶段：Mybatis 接口代理类将 Mapper 接口方法的调用，转换为 <code>SqlSession</code> 数据库操作的调用。</h4><p>Mybatis 接口代理类的主要工作是：在增强代码中，根据接口的方法信息和 Mapper 映射配置文件信息，确定最终要执行的 <code>SqlSession</code> 的数据库操作并执行。</p>
<p>比如 <code>accountMapper.selectByActno(actno)</code> 经过增强代码的分析后，能够最终去调用 <code>sqlSession.selectList()</code> 来执行数据库操作。</p>
<p>需要注意的是，这里动态代理转换后，最终确定的 <code>sqlSession.selectList()</code> 中的 <code>sqlSession</code> 是一个 <code>SqlSessionTemplate</code> 类型的对象，而不是 <code>DefaultSqlSession</code> 类型的对象。</p>
<h4 id="第三阶段：SqlSessionTemplate-通过动态代理将要执行的数据库操作转发给绑定到当前线程的-DefaultSqlSession-来执行"><a href="#第三阶段：SqlSessionTemplate-通过动态代理将要执行的数据库操作转发给绑定到当前线程的-DefaultSqlSession-来执行" class="headerlink" title="第三阶段：SqlSessionTemplate 通过动态代理将要执行的数据库操作转发给绑定到当前线程的 DefaultSqlSession 来执行"></a>第三阶段：<code>SqlSessionTemplate</code> 通过动态代理将要执行的数据库操作转发给绑定到当前线程的 <code>DefaultSqlSession</code> 来执行</h4><p>现在终于要执行数据库操作了，比如 <code>sqlSession.selectList()</code>，此时 <code>sqlSession</code> 是一个 <code>SqlSessionTemplate</code> 类型的对象。</p>
<p><code>SqlSessionTemplate</code> 是 Spring + Mybatis 整合场景下，解决 <code>SqlSession</code> 线程安全问题的关键对象。该对象虽然实现了 <code>SqlSession</code> 接口，但所有的数据库操作，实际上都是其内部封装的属性 <code>sqlSessionProxy</code> 来执行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSessionProxy;</span><br></pre></td></tr></table></figure>
<p>而 <code>sqlSessionProxy</code> 本身也不实际执行数据库操作，正如它的名字，它是一个 <code>SqlSession</code> 接口的动态代理。实际的数据库操作，在 <code>sqlSessionProxy</code> 所绑定的调用处理器中完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">SqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(</span><br><span class="line">        SqlSessionFactory.class.getClassLoader(),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Class</span>[] &#123; SqlSession.class &#125;, </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SqlSessionInterceptor</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">SqlSessionInterceptor</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 代理增强：获取当前线程的 SqlSession 对象，类型为 DefaultSqlSession</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> getSqlSession(SqlSessionTemplate.<span class="built_in">this</span>.sqlSessionFactory, SqlSessionTemplate.<span class="built_in">this</span>.executorType, SqlSessionTemplate.<span class="built_in">this</span>.exceptionTranslator);</span><br><span class="line">    <span class="comment">// 目标方法：通过当前线程的 DefaultSqlSession 对象来执行数据库操作</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(sqlSession, args);</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，问题的关键就是 <code>getSqlSession</code> 底层到底是怎么获取当前线程的 <code>SqlSession</code> 对象的。</p>
<p>先说明一下 <code>getSqlSession</code> 的第一个参数，<code>SqlSessionTemplate</code> 这个类中还包括一个 <code>SqlSessionFactory</code> 属性，该属性注入的就是 <code>SqlSessionFactoryBean</code> 的 <code>getObject()</code> 的结果，是一个 <code>DefaultSqlSessionFactory</code> 类型的对象。</p>
<p><code>SqlSessionTemplate</code> 内置该属性的目的就是，当获取不到当前线程的 <code>SqlSession</code> 对象时，通过该属性可以去创建一个！所以，在上面的注释中，我说获取到当前线程的 <code>SqlSession</code> 对象是 <code>DefaultSqlSession</code> 类型的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程的 SqlSessionHolder 对象</span></span><br><span class="line">    <span class="type">SqlSessionHolder</span> <span class="variable">holder</span> <span class="operator">=</span> (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);</span><br><span class="line">    <span class="comment">// 取出当前线程 SqlSession</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">session</span> <span class="operator">=</span> holder.getSqlSession();</span><br><span class="line">    <span class="comment">// 如果当前线程的 SqlSession 存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (session != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> session;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则不存在，利用 sessionFactory 创建新的 SqlSession</span></span><br><span class="line">    session = sessionFactory.openSession(executorType);</span><br><span class="line">    <span class="comment">// 创建完成后，将该新建的 SqlSession 封装为 SqlSessionHolder 绑定到当前线程上</span></span><br><span class="line">    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第一阶段中，我们就是将当前线程的 <code>Connection</code> 封装为一个 <code>ConnectionHolder</code> 绑定到 <code>resources</code> 中。但是这里要获取的不是 <code>ConnectionHolder</code> 而是 <code>SqlSessionHolder</code>，所以第一次执行时，这里 <code>resources.get()</code> 所得到的 <code>Map&lt;Object, Object&gt;</code> 集合中只包括 <code>(dataSource, ConnectionHolder)</code> 这一个键值对。</p>
<p>既然获取不到，我们就 <code>sessionFactory.openSession()</code> 创建一个新的 <code>SqlSession</code> 来返回。</p>
<p>在返回之前，我们还需要做一些工作：将新的 <code>SqlSession</code> 绑定到当前线程。具体看 <code>registerSessionHolder</code> 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerSessionHolder</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator, SqlSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 将 SqlSession 封装到 SqlSessionHolder 中</span></span><br><span class="line">    <span class="type">SqlSessionHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionHolder</span>(session, executorType, exceptionTranslator);</span><br><span class="line">    <span class="comment">// 以 sessionFactory 为 key，将 SqlSessionHolder 绑定到当前线程</span></span><br><span class="line">    TransactionSynchronizationManager.bindResource(sessionFactory, holder);</span><br><span class="line">    <span class="comment">// 这一步非常关键：注册事务同步！我们后面再说！</span></span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> <span class="title class_">SqlSessionSynchronization</span>(holder, sessionFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得我们在第一阶段，通过 Spring AOP 为当前线程绑定的 <code>Connection</code> 对象吧。</p>
<p>现在我们为当前线程绑定了两个对象：<code>SqlSession</code> 和 <code>Connection</code>。但显然，这两个对象之间还没建立起关系，所谓的建立起关系，就是将 <code>SqlSession</code> 底层的 <code>Connection</code> 设置为当前线程绑定的 <code>Connection</code>。</p>
<p>关系的建立被推迟到数据库操作的执行时。回到 <code>SqlSessionInterceptor</code> 的目标方法部分，目前我们已经获取到了一个 <code>DefaultSqlSession</code> 类型的对象，该对象底层使用的事务管理器是 <code>SpringManagedTransactionFactory</code>。</p>
<p>由于还没有第一次执行数据库操作，当前的 <code>DefaultSqlSession</code> 底层的 <code>SpringManagedTransactionFactory</code> 中的 <code>Connection</code> 还是 <code>null</code>。</p>
<p>当真正执行时，会发现该 <code>Connection</code> 为 <code>null</code>，然后从 <code>resources</code> 获取之前绑定到当前线程的 <code>ConnectionHolder</code>，从中取出 <code>Connection</code> 进行赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpringManagedTransactionFactory</span></span><br><span class="line"><span class="keyword">public</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.connection == <span class="literal">null</span>) &#123;</span><br><span class="line">      openConnection();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SpringManagedTransactionFactory</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">openConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="built_in">this</span>.connection = DataSourceUtils.getConnection(<span class="built_in">this</span>.dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataSourceUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> CannotGetJdbcConnectionException &#123;</span><br><span class="line">    <span class="keyword">return</span> doGetConnection(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataSourceUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">doGetConnection</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">ConnectionHolder</span> <span class="variable">conHolder</span> <span class="operator">=</span> (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> conHolder.getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mybatis 的事务管理器和 Spring 的事务管理器，底层所操作的 <code>Connection</code> 对象到这一步才终于达成了一致。</p>
<h4 id="第四阶段：Spring-AOP-在目标业务方法执行结束后，在后置增强中完成事务的提交、回滚与关闭"><a href="#第四阶段：Spring-AOP-在目标业务方法执行结束后，在后置增强中完成事务的提交、回滚与关闭" class="headerlink" title="第四阶段：Spring AOP 在目标业务方法执行结束后，在后置增强中完成事务的提交、回滚与关闭"></a>第四阶段：Spring AOP 在目标业务方法执行结束后，在后置增强中完成事务的提交、回滚与关闭</h4><p>在 Spring 的事务管理中，业务方法作为 Spring AOP 的目标方法：</p>
<ul>
<li>其前置增强，是 Spring 事务管理器创建并开启事务</li>
<li>其后置增强，是 Spring 事务管理器完成事务的提交、回滚与关闭</li>
</ul>
<p>事务的提交、回滚与关闭，除了对底层的 <code>Connection</code> 对象执行 <code>commit</code> <code>rollback</code> 和 <code>close</code> 以外，我们可能还需要做其他的一些操作，比如最容易想到的，在事务提交或回滚之前，从 <code>resources</code> 移除掉绑定到当前线程的 <code>Connection</code> 对象和 <code>SqlSession</code> 对象。</p>
<p>这些额外操作被称为事务同步操作，它们与事务本身的提交或回滚并不直接相关，它们可以在事务的不同阶段（事务的生命周期）被触发。</p>
<p>我们现在回过头来，应该就能明白第三阶段提到的，注册事务同步是什么意思了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerSessionHolder</span><span class="params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator, SqlSession session)</span> &#123;</span><br><span class="line">    <span class="comment">// 将 SqlSession 封装到 SqlSessionHolder 中</span></span><br><span class="line">    <span class="type">SqlSessionHolder</span> <span class="variable">holder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionHolder</span>(session, executorType, exceptionTranslator);</span><br><span class="line">    <span class="comment">// 以 sessionFactory 为 key，将 SqlSessionHolder 绑定到当前线程</span></span><br><span class="line">    TransactionSynchronizationManager.bindResource(sessionFactory, holder);</span><br><span class="line">    <span class="comment">// 这一步非常关键：注册事务同步！我们后面再说！</span></span><br><span class="line">    TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> <span class="title class_">SqlSessionSynchronization</span>(holder, sessionFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring 在将 <code>SqlSession</code> 绑定到当前线程之后，紧接着立刻为其创建了一个 <code>SqlSessionSynchronization</code> 事务同步器，并将该事务同步器也绑定到当前线程。只不过 <code>SqlSession</code> 是绑定到 <code>resources</code> 上，事务同步器是绑定到 <code>TransactionSynchronizationManager</code> 类中的另外一个 <code>ThreadLocal</code> 变量 <code>synchronizations</code> 上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为当前线程绑定 Connection 与 SqlSession</span></span><br><span class="line">ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources;</span><br><span class="line"><span class="comment">// 为当前线程的 SqlSession 绑定对应的事务同步器</span></span><br><span class="line">ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations;</span><br></pre></td></tr></table></figure>
<p>PS：<code>SqlSessionSynchronization</code> 是 <code>mybatis-spring</code> 提供的事务同步器实现，其中的事务同步操作已经写好了。</p>
<p>在目标业务方法执行完成以后，Spring AOP 实现会在其后置增强部分完成两部分工作：</p>
<ul>
<li>获取绑定到当前线程的 <code>Connection</code>，执行 <code>commit</code> <code>rollback</code> 以及 <code>close</code> 操作</li>
<li>获取绑定到当前线程的事务同步器，在 <code>commit</code> 方法执行前后触发一些事务同步操作，在 <code>rollback</code> 方法执行前后触发一些事务同步操作等</li>
</ul>
<p>Spring 的事务管理器中会对 <code>Connection</code> 做 <code>commit</code> 操作，Mybatis 的 <code>SqlSession</code> 其底层的事务也会做 <code>commit</code> 操作。那会不会出现重复 <code>commit</code> 的情况呢？</p>
<p>答案是不会，可以看一下 Mybatis 的事务管理器 <code>SpringManagedTransaction</code> 的源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.connection != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.isConnectionTransactional &amp;&amp; !<span class="built_in">this</span>.autoCommit) &#123;</span><br><span class="line">        LOGGER.debug(() -&gt; <span class="string">&quot;Committing JDBC Connection [&quot;</span> + <span class="built_in">this</span>.connection + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.connection.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 if 语句的第二个条件 <code>!this.isConnectionTransactional</code>，它表示检查当前连接对象是否被 Spring 事务所管理，如果是的话，将不会对 <code>SqlSession</code> 底层的 <code>Connection</code> 执行 <code>commit</code> 操作。</p>
<p>也就是说，Spring 的事务管理器会调用 Mybatis 的事务管理器去执行 <code>commit</code> 操作，只不过 Mybatis 事务管理器自己内部会拒绝提交，最终交给 Spring 的事务管理器来完成提交。</p>
<h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/tianjindong0804/article/details/106259905">源码分析——MyBatis与Spring整合后如何保证SqlSession线程安全</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">RQTN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/atguigu-springmvc/SSM%20%E6%95%B4%E5%90%88%20-%20Spring%20%E4%B8%8E%20MyBatis%20%E7%9A%84%E6%95%B4%E5%90%88%E7%BB%86%E8%8A%82/">http://example.com/atguigu-springmvc/SSM%20%E6%95%B4%E5%90%88%20-%20Spring%20%E4%B8%8E%20MyBatis%20%E7%9A%84%E6%95%B4%E5%90%88%E7%BB%86%E8%8A%82/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">RQTN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/atguigu-springmvc/">atguigu-springmvc</a><a class="post-meta__tags" href="/tags/Mybatis-%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/">Mybatis 接口代理机制</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/atguigu-springmvc/%E7%AC%AC%208%20%E7%AB%A0%20HttpMessageConverter%20-%20%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%87%E5%86%85%E5%AE%B9%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/" title="HttpMessageConverter - 响应中文内容乱码问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HttpMessageConverter - 响应中文内容乱码问题</div></div></a></div><div class="next-post pull-right"><a href="/atguigu-springboot2/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%20-%20@Configuration%20%E7%9A%84%20proxyBeanMethods%20%E5%B1%9E%E6%80%A7%E4%B8%8E%20@Bean%20%E6%96%B9%E6%B3%95/" title="Configuration 的 proxyBeanMethods 属性与 Bean 方法"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Configuration 的 proxyBeanMethods 属性与 Bean 方法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/atguigu-springmvc/%E7%AC%AC%208%20%E7%AB%A0%20HttpMessageConverter%20-%20@RequestBody%20%E5%92%8C%20@ResponseBody%20%E6%98%AF%E5%A6%82%E4%BD%95%E7%AE%80%E5%8C%96%E5%BC%80%E5%8F%91%E7%9A%84/" title="HttpMessageConverter - @RequestBody 和 @ResponseBody 是如何简化开发的"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-23</div><div class="title">HttpMessageConverter - @RequestBody 和 @ResponseBody 是如何简化开发的</div></div></a></div><div><a href="/atguigu-springmvc/%E7%AC%AC%208%20%E7%AB%A0%20HttpMessageConverter%20-%20%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%87%E5%86%85%E5%AE%B9%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/" title="HttpMessageConverter - 响应中文内容乱码问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-23</div><div class="title">HttpMessageConverter - 响应中文内容乱码问题</div></div></a></div><div><a href="/laodu-mybatis/%E7%AC%AC%208%20%E7%AB%A0%20MyBatis%20%E4%B8%AD%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BD%BF%E7%94%A8%20-%20sqlSession.getMapper()%20%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/" title="MyBatis 中接口代理机制及使用 - sqlSession.getMapper() 的使用问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-22</div><div class="title">MyBatis 中接口代理机制及使用 - sqlSession.getMapper() 的使用问题</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RQTN</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RQTN"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RQTN" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SSM-%E6%95%B4%E5%90%88-Spring-%E4%B8%8E-MyBatis-%E7%9A%84%E6%95%B4%E5%90%88%E7%BB%86%E8%8A%82"><span class="toc-number">1.</span> <span class="toc-text">SSM 整合 - Spring 与 MyBatis 的整合细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E4%B8%80%EF%BC%9ASqlSessionFactoryBean-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%8C%E6%88%90%E9%85%8D%E7%BD%AE%E8%BD%AC%E7%A7%BB%E7%9A%84"><span class="toc-number">1.1.</span> <span class="toc-text">细节一：SqlSessionFactoryBean 是如何完成配置转移的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E4%BA%8C%EF%BC%9A-lt-transactionManager-type-quot-JDBC-quot-gt-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">细节二：&lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; 的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E4%B8%89%EF%BC%9AMapperScannerConfigurer-%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">细节三：MapperScannerConfigurer 的底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3-BeanDefinitionRegistryPostProcessor-%E6%8E%A5%E5%8F%A3%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">了解 BeanDefinitionRegistryPostProcessor 接口原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E9%98%B6%E6%AE%B5%EF%BC%9AMapperScannerConfigurer-%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E5%8C%85%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89-Mapper-%E6%8E%A5%E5%8F%A3%EF%BC%8C%E4%B8%BA%E5%85%B6%E5%88%9B%E5%BB%BA-BeanDefinition-%E5%B9%B6%E6%B3%A8%E5%86%8C%E5%88%B0-Spring-%E4%B8%AD"><span class="toc-number">1.3.2.</span> <span class="toc-text">扫描阶段：MapperScannerConfigurer 扫描指定包下的所有 Mapper 接口，为其创建 BeanDefinition 并注册到 Spring 中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E6%95%B4-%E4%BF%AE%E6%94%B9%E9%98%B6%E6%AE%B5%EF%BC%9AMapperScannerConfigurer-%E5%AF%B9%E6%96%B0%E5%88%9B%E5%BB%BA-BeanDefinition-%E8%BF%9B%E8%A1%8C%E8%B0%83%E6%95%B4%EF%BC%8C%E7%A1%AE%E4%BF%9D-Spring-%E6%A0%B9%E6%8D%AE%E8%B0%83%E6%95%B4%E5%90%8E%E7%9A%84-BeanDefinition-%E6%89%80%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA-MapperFactoryBean-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.3.</span> <span class="toc-text">调整&#x2F;修改阶段：MapperScannerConfigurer 对新创建 BeanDefinition 进行调整，确保 Spring 根据调整后的 BeanDefinition 所实例化的是一个 MapperFactoryBean 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-MapperFactoryBean-%E5%88%B0-Mapper-%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BB%A3%E7%90%86%E7%B1%BB"><span class="toc-number">1.3.4.</span> <span class="toc-text">从 MapperFactoryBean 到 Mapper 接口的代理类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E5%9B%9B%EF%BC%9AMybatis-%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E5%92%8C-Spring-%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8-txManager-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">细节四：Mybatis 的事务管理器和 Spring 的事务管理器 txManager 的关系是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E8%8A%82%E4%BA%94%EF%BC%9A%E5%9C%A8-Spring-%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%8B%EF%BC%8CSpring-%E5%92%8C-Mybatis-%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">细节五：在 Spring 声明式事务下，Spring 和 Mybatis 的两个事务管理器是如何协同工作的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9ASpring-AOP-%E6%8B%A6%E6%88%AA%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%8C%E4%B8%BA%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%B9%B6%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.5.1.</span> <span class="toc-text">第一阶段：Spring AOP 拦截业务方法的调用，为当前线程创建并开启事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9AMybatis-%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E7%B1%BB%E5%B0%86-Mapper-%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8%EF%BC%8C%E8%BD%AC%E6%8D%A2%E4%B8%BA-SqlSession-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%9A%84%E8%B0%83%E7%94%A8%E3%80%82"><span class="toc-number">1.5.2.</span> <span class="toc-text">第二阶段：Mybatis 接口代理类将 Mapper 接口方法的调用，转换为 SqlSession 数据库操作的调用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9ASqlSessionTemplate-%E9%80%9A%E8%BF%87%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%B0%86%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E8%BD%AC%E5%8F%91%E7%BB%99%E7%BB%91%E5%AE%9A%E5%88%B0%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%9A%84-DefaultSqlSession-%E6%9D%A5%E6%89%A7%E8%A1%8C"><span class="toc-number">1.5.3.</span> <span class="toc-text">第三阶段：SqlSessionTemplate 通过动态代理将要执行的数据库操作转发给绑定到当前线程的 DefaultSqlSession 来执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9ASpring-AOP-%E5%9C%A8%E7%9B%AE%E6%A0%87%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9D%9F%E5%90%8E%EF%BC%8C%E5%9C%A8%E5%90%8E%E7%BD%AE%E5%A2%9E%E5%BC%BA%E4%B8%AD%E5%AE%8C%E6%88%90%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4%E3%80%81%E5%9B%9E%E6%BB%9A%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-number">1.5.4.</span> <span class="toc-text">第四阶段：Spring AOP 在目标业务方法执行结束后，在后置增强中完成事务的提交、回滚与关闭</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2"><span class="toc-number">1.6.</span> <span class="toc-text">参考博客</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-mysql/MVCC%20-%20undo%20log%20%E7%89%88%E6%9C%AC%E9%93%BE%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99/" title="MVCC - undo log 版本链数据访问规则">MVCC - undo log 版本链数据访问规则</a><time datetime="2023-06-27T14:19:24.000Z" title="发表于 2023-06-27 22:19:24">2023-06-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/synchronized%20%E5%8E%9F%E7%90%86/" title="synchronized 原理">synchronized 原理</a><time datetime="2023-05-04T09:46:08.000Z" title="发表于 2023-05-04 17:46:08">2023-05-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--重量级锁">好文收录 - 死磕Synchronized底层实现--重量级锁</a><time datetime="2023-04-27T17:00:08.000Z" title="发表于 2023-04-28 01:00:08">2023-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--轻量级锁">好文收录 - 死磕Synchronized底层实现--轻量级锁</a><time datetime="2023-04-26T17:00:08.000Z" title="发表于 2023-04-27 01:00:08">2023-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E5%81%8F%E5%90%91%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--偏向锁">好文收录 - 死磕Synchronized底层实现--偏向锁</a><time datetime="2023-04-25T17:00:08.000Z" title="发表于 2023-04-26 01:00:08">2023-04-26</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By RQTN</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://unpkg.com/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>