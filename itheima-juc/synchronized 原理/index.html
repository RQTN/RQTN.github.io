<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>synchronized 原理 | RQTN</title><meta name="author" content="RQTN"><meta name="copyright" content="RQTN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="synchronized 原理 本文是对于 死磕Synchronized底层实现 系列的个人补充  死磕Synchronized底层实现—概论 死磕Synchronized底层实现—偏向锁 死磕Synchronized底层实现—轻量级锁 死磕Synchronized底层实现—重量级锁   优秀博文推荐关于 synchronized 原理的解析众说纷纭，尤其是 jdk1.6 以后引入的相关锁优化的内">
<meta property="og:type" content="article">
<meta property="og:title" content="synchronized 原理">
<meta property="og:url" content="http://example.com/itheima-juc/synchronized%20%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="RQTN">
<meta property="og:description" content="synchronized 原理 本文是对于 死磕Synchronized底层实现 系列的个人补充  死磕Synchronized底层实现—概论 死磕Synchronized底层实现—偏向锁 死磕Synchronized底层实现—轻量级锁 死磕Synchronized底层实现—重量级锁   优秀博文推荐关于 synchronized 原理的解析众说纷纭，尤其是 jdk1.6 以后引入的相关锁优化的内">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2023-05-04T09:46:08.000Z">
<meta property="article:modified_time" content="2024-04-01T03:35:36.118Z">
<meta property="article:author" content="RQTN">
<meta property="article:tag" content="itheima-juc">
<meta property="article:tag" content="synchronized">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/itheima-juc/synchronized%20%E5%8E%9F%E7%90%86/index.html"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: RQTN","link":"链接: ","source":"来源: RQTN","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'synchronized 原理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-01 11:35:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index_img_cut.png')"><nav id="nav"><span id="blog-info"><a href="/" title="RQTN"><span class="site-name">RQTN</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">synchronized 原理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-05-04T09:46:08.000Z" title="发表于 2023-05-04 17:46:08">2023-05-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/JUC/">JUC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>57分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="synchronized 原理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a><code>synchronized</code> 原理</h2><blockquote>
<p>本文是对于 <code>死磕Synchronized底层实现</code> 系列的个人补充</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/12">死磕Synchronized底层实现—概论</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/13">死磕Synchronized底层实现—偏向锁</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/14">死磕Synchronized底层实现—轻量级锁</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/15">死磕Synchronized底层实现—重量级锁</a></li>
</ul>
</blockquote>
<h3 id="优秀博文推荐"><a href="#优秀博文推荐" class="headerlink" title="优秀博文推荐"></a>优秀博文推荐</h3><p>关于 <code>synchronized</code> 原理的解析众说纷纭，尤其是 <code>jdk1.6</code> 以后引入的相关锁优化的内容。</p>
<p>远古巨著 <strong><em>Java Concurrency in Practice</em></strong> 出版时间较早，因此没有锁优化的内容讲解。</p>
<p>:star::star::star: <strong><em>深入理解 Java 虚拟机（第 3 版）</em></strong> 最后一个章节对锁优化的内容做了讲解，并给出了一张经典的关系图，如下：</p>
<p><img src="/img/itheima-juc/Snipaste_2023-10-06_23-25-57.png" alt=""></p>
<p>但是毕竟是 JVM 的书籍，锁优化内容的讲解相对来说还是较简略的。</p>
<p>下面是在网络上找到的一些讲解 <code>synchronized</code> 原理的优秀博文：</p>
<ul>
<li>:star::star::star::star::star: <a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/12">死磕Synchronized底层实现</a>：该系列总共有四篇文章，基于 <code>Hotspot jdk8u</code> 源码讲解，<strong>至少第一篇概论是需要完全搞懂的</strong>。</li>
</ul>
<ul>
<li>:star::star::star::star: <a target="_blank" rel="noopener" href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事</a>：该博文参考了<a target="_blank" rel="noopener" href="https://github.com/farmerjohngit/myblog/issues/12">死磕Synchronized底层实现</a>系列的四篇文章，可以对照着看，作为补充。本文有一张更详细的关系图（大体是对的，但部分细节流程和源码不太一致）：<br> <img src="/img/itheima-juc/-----3.svg" alt="">   </li>
</ul>
<ul>
<li><p>:star::star::star: <a target="_blank" rel="noopener" href="https://juejin.cn/post/7046921350065160206">难搞的偏向锁终于被 Java 移除了</a>：适合新手入门的讲解，不涉及 <code>Hotspot jdk8u</code> 的源码。</p>
<p>关于批量撤销一节，原文中如下内容存在问题：</p>
<blockquote>
<p>如果在距离上次批量重偏向发生超过 25 秒之外，那么就会重置在 [20, 40) 内的计数, 再给次机会</p>
</blockquote>
<p>在 <code>Hotspot Jdk8u</code> 版本下，如果批量重偏向发生后的 25 秒内，偏向撤销次数没有从 20 达到批量撤销阈值 40，此时不是重置 [20, 40) 内的计数（即重置到 20），而是直接重置为 0，这意味着批量重偏向是可以再次发生的！</p>
<p><a target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/69087d08d473/src/share/vm/runtime/biasedLocking.cpp#l295">Hotspot Jdk8u 源码</a> 如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">HeuristicsResult</span> &#123;</span><br><span class="line">  HR_NOT_BIASED    = <span class="number">1</span>, <span class="comment">// 锁对象偏向模式关闭的情况：无需偏向撤销</span></span><br><span class="line">  HR_SINGLE_REVOKE = <span class="number">2</span>, <span class="comment">// 单次偏向撤销</span></span><br><span class="line">  HR_BULK_REBIAS   = <span class="number">3</span>, <span class="comment">// 批量重偏向</span></span><br><span class="line">  HR_BULK_REVOKE   = <span class="number">4</span>  <span class="comment">// 批量撤销</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递增锁对象的 klass 中的偏向撤销计数，并返回结果</span></span><br><span class="line"><span class="function"><span class="type">static</span> HeuristicsResult <span class="title">update_heuristics</span><span class="params">(oop o, <span class="type">bool</span> allow_rebias)</span> </span>&#123;</span><br><span class="line">  markOop mark = o-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (!mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    <span class="comment">// 锁对象偏向模式关闭的情况</span></span><br><span class="line">    <span class="keyword">return</span> HR_NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取对象的 class 信息</span></span><br><span class="line">  Klass* k = o-&gt;<span class="built_in">klass</span>();</span><br><span class="line">  <span class="comment">// 获得当前时间</span></span><br><span class="line">  jlong cur_time = os::<span class="built_in">javaTimeMillis</span>();</span><br><span class="line">  <span class="comment">// 获得上次批量重偏向的时间</span></span><br><span class="line">  jlong last_bulk_revocation_time = k-&gt;<span class="built_in">last_biased_lock_bulk_revocation_time</span>();</span><br><span class="line">  <span class="comment">// 获取 class 中记录的偏向撤销次数</span></span><br><span class="line">  <span class="type">int</span> revocation_count = k-&gt;<span class="built_in">biased_lock_revocation_count</span>();</span><br><span class="line">  <span class="comment">// 如果 偏向撤销次数 &gt;= 批量重偏向阈值 且 </span></span><br><span class="line">  <span class="comment">//     偏向撤销次数 &lt; 批量撤销阈值 且</span></span><br><span class="line">  <span class="comment">//     距离上次批量重偏向的时间超过了指定时间</span></span><br><span class="line">  <span class="keyword">if</span> ((revocation_count &gt;= BiasedLockingBulkRebiasThreshold) &amp;&amp;</span><br><span class="line">      (revocation_count &lt;  BiasedLockingBulkRevokeThreshold) &amp;&amp;</span><br><span class="line">      (last_bulk_revocation_time != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">      (cur_time - last_bulk_revocation_time &gt;= BiasedLockingDecayTime)) &#123;</span><br><span class="line">      <span class="comment">// 重置 class 中记录的偏向撤销次数为 0</span></span><br><span class="line">      k-&gt;<span class="built_in">set_biased_lock_revocation_count</span>(<span class="number">0</span>);</span><br><span class="line">      revocation_count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (revocation_count &lt;= BiasedLockingBulkRevokeThreshold) &#123;</span><br><span class="line">    <span class="comment">// 原子递增偏向撤销计数</span></span><br><span class="line">    revocation_count = k-&gt;<span class="built_in">atomic_incr_biased_lock_revocation_count</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (revocation_count == BiasedLockingBulkRevokeThreshold) &#123;</span><br><span class="line">    <span class="comment">// 递增后，偏向撤销计数到达批量撤销阈值</span></span><br><span class="line">    <span class="keyword">return</span> HR_BULK_REVOKE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (revocation_count == BiasedLockingBulkRebiasThreshold) &#123;</span><br><span class="line">    <span class="comment">// 递增后，偏向撤销计数到达批量重偏向阈值</span></span><br><span class="line">    <span class="keyword">return</span> HR_BULK_REBIAS;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单次偏向撤销的情况</span></span><br><span class="line">  <span class="keyword">return</span> HR_SINGLE_REVOKE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>:star::star::star::star::star: <a target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk8u/jdk8u/hotspot">jdk8u/hotspot 源码</a>：网站阅读体验不友好，建议直接下载完整源码，在本地进行源码的阅读</p>
</li>
</ul>
<h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="klass-lockee-LockRecord-三者的联系"><a href="#klass-lockee-LockRecord-三者的联系" class="headerlink" title="klass, lockee, LockRecord 三者的联系"></a>klass, lockee, LockRecord 三者的联系</h4><p><code>lockee</code> 是锁对象，<code>klass</code> 是锁对象的类元数据信息，<code>LockRecord</code> 是每次加锁都会产生的一个锁记录</p>
<p><img src="/img/itheima-juc/klass、lockee、LockRecord三者的联系.svg" alt=""></p>
<p>每次加锁，无论是偏向锁、轻量级锁还是重量级锁，都会在获取锁的线程的栈空间中添加一个 <code>LockRecord</code> 锁记录，并让 <code>LockRecord</code> 的 <code>obj</code> 指向 <code>lockee</code>。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><h4 id="偏向锁以及轻量级锁的加锁流程"><a href="#偏向锁以及轻量级锁的加锁流程" class="headerlink" title="偏向锁以及轻量级锁的加锁流程"></a>偏向锁以及轻量级锁的加锁流程</h4><p><img src="/img/itheima-juc/偏向锁以及轻量级锁的加锁流程.svg" alt=""></p>
<h4 id="偏向锁的锁重入"><a href="#偏向锁的锁重入" class="headerlink" title="偏向锁的锁重入"></a>偏向锁的锁重入</h4><p><img src="/img/itheima-juc/偏向锁的锁重入示意图.svg" alt=""></p>
<h4 id="从偏向撤销-锁升级入口-InterpreterRuntime-monitorenter-开始分析整个偏向撤销流程"><a href="#从偏向撤销-锁升级入口-InterpreterRuntime-monitorenter-开始分析整个偏向撤销流程" class="headerlink" title="从偏向撤销/锁升级入口 InterpreterRuntime::monitorenter 开始分析整个偏向撤销流程"></a>从偏向撤销/锁升级入口 <code>InterpreterRuntime::monitorenter</code> 开始分析整个偏向撤销流程</h4><p>什么情况下会进入 <code>InterpreterRuntime::monitorenter</code> 方法？</p>
<ul>
<li>获取偏向锁时发现锁对象已经偏向其他线程</li>
<li>尝试获取轻量级锁</li>
<li>尝试获取处于膨胀中状态的锁</li>
<li>尝试获取重量级锁</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="type">void</span>, InterpreterRuntime::<span class="built_in">monitorenter</span>(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  <span class="built_in">assert</span>(Universe::<span class="built_in">heap</span>()-&gt;<span class="built_in">is_in_reserved_or_null</span>(<span class="built_in">h_obj</span>()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// fast_enter 主要是处理偏向锁的偏向撤销，由于当前线程偏向撤销后还要继续获得锁，因此在最后又调用了 slow_enter</span></span><br><span class="line">    <span class="comment">// 尝试获取轻量级锁、处于膨胀中状态的锁、重量级锁也会进入 fast_enter，但会跳过所有偏向锁的偏向撤销逻辑，直接进入最后调用的 slow_enter</span></span><br><span class="line">    ObjectSynchronizer::<span class="built_in">fast_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// slow_enter 主体是处理线程发生竞争的逻辑，主要有四种情况：</span></span><br><span class="line">    <span class="comment">// (1) 偏向锁撤销后再次尝试获取锁</span></span><br><span class="line">    <span class="comment">// (2) 最开始尝试获取轻量级锁</span></span><br><span class="line">    <span class="comment">// (3) 最开始尝试获取处于膨胀中状态的锁</span></span><br><span class="line">    <span class="comment">// (4) 最开始尝试获取重量级锁</span></span><br><span class="line">    ObjectSynchronizer::<span class="built_in">slow_enter</span>(h_obj, elem-&gt;<span class="built_in">lock</span>(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>
<p>偏向撤销逻辑主要看 <code>ObjectSynchronizer::fast_enter</code> 的内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock, <span class="type">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>()) &#123;</span><br><span class="line">      <span class="comment">// 如果是 Java 线程，执行的是该分支（一般是这条分支）</span></span><br><span class="line">      <span class="comment">// revoke_and_rebias 方法中包含了非常多种情况的处理，主要可以分为三类</span></span><br><span class="line">      <span class="comment">// (1) 重偏向，返回 BIAS_REVOKED_AND_REBIASED </span></span><br><span class="line">      <span class="comment">// (2) 偏向撤销，返回 BIAS_REVOKED</span></span><br><span class="line">      <span class="comment">// (3) 锁对象不是偏向模式：可能是轻量级锁/锁膨胀/重量级锁，方法什么都不做，直接返回 NOT_BIASED</span></span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">         <span class="comment">// 重偏向是将锁对象重新偏向当前线程，这意味着当前线程成功获取到了偏向锁</span></span><br><span class="line">         <span class="comment">// 因此可以直接退出，不用进入最后的 slow_enter </span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是 VM 线程，执行的是该分支</span></span><br><span class="line">      <span class="built_in">assert</span>(!attempt_rebias, <span class="string">&quot;can not rebias toward VM thread&quot;</span>);</span><br><span class="line">      BiasedLocking::<span class="built_in">revoke_at_safepoint</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 进入 `slow_enter` 存在非常多种情况：只要不是重偏向，剩下的逻辑都会进入 slow_enter，后续再进行解析</span></span><br><span class="line"> <span class="built_in">slow_enter</span> (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点是 Java 线程那条分支，这里可能会让人比较疑惑，当前线程明明是带着偏向撤销的目的来的，怎么 <code>revoke_and_rebias</code> 给当前线程来了一次重偏向的操作呢？这是因为存在批量重偏向的两种情况</p>
<ul>
<li>当前线程在真正做偏向撤销操作前，还会再次检查锁对象的 <code>epoch</code> 是否过期。如果发现过期了（之前获取偏向锁时还未过期），说明期间有其他线程先一步做了偏向撤销，并触发了一次批量重偏向（批量重偏向操作的第一步就是将 <code>Klass</code> 的 <code>epoch</code> 加 1），此时，直接将锁对象重偏向为当前线程即可。</li>
<li>当前线程的这次偏向撤销操作恰好让偏向撤销计数递增到批量重偏向阈值，因此会在 VM 线程执行完批量重偏向后，再将锁对象重偏向为当前线程。</li>
</ul>
<p>具体还是要深入看 <code>BiasedLocking::revoke_and_rebias</code> 的内容：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BiasedLocking::Condition <span class="title">BiasedLocking::revoke_and_rebias</span><span class="params">(Handle obj, <span class="type">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>(), <span class="string">&quot;must not be called while at safepoint&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_biased_anonymously</span>() &amp;&amp; !attempt_rebias) &#123;</span><br><span class="line">    <span class="comment">// 奇怪的分支情况：锁对象的 markword 处于匿名可偏向状态，却又不允许重偏向</span></span><br><span class="line">    <span class="comment">// 据说是处理偏向锁对象调用过 hashCode 的情况（这里不用关心）</span></span><br><span class="line">    markOop biased_value       = mark;</span><br><span class="line">    markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">    markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">    <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    <span class="comment">// 锁对象仍然是偏向模式</span></span><br><span class="line">    Klass* k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">    <span class="keyword">if</span> (!prototype_header-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      <span class="comment">// 当前线程在上次进入 InterpreterRuntime::monitorenter 到最终执行到这行代码期间</span></span><br><span class="line">      <span class="comment">// 锁对象发生了批量撤销的情况（批量撤销的第一步就是关闭 Klass 的偏向模式），因此尝试 cas 锁对象的对象头为无锁状态</span></span><br><span class="line">      markOop biased_value       = mark;</span><br><span class="line">      markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(prototype_header, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">      <span class="built_in">assert</span>(!(*(obj-&gt;<span class="built_in">mark_addr</span>()))-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;even if we raced, should still be revoked&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prototype_header-&gt;<span class="built_in">bias_epoch</span>() != mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">      <span class="comment">// 当前线程在上次进入 InterpreterRuntime::monitorenter 到最终执行到这行代码期间</span></span><br><span class="line">      <span class="comment">// 锁对象发生了批量重偏向的情况（批量重偏向的第一步就是将 Klass 的 epoch 加 1），因此尝试 cas 锁对象的对象头使其重偏向为当前线程</span></span><br><span class="line">      <span class="keyword">if</span> (attempt_rebias) &#123; <span class="comment">// 只关注允许重偏向的分支</span></span><br><span class="line">        <span class="built_in">assert</span>(THREAD-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop rebiased_prototype = markOopDesc::<span class="built_in">encode</span>((JavaThread*) THREAD, mark-&gt;<span class="built_in">age</span>(), prototype_header-&gt;<span class="built_in">bias_epoch</span>());</span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(rebiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED_AND_REBIASED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(mark-&gt;<span class="built_in">age</span>());</span><br><span class="line">        markOop res_mark = (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(unbiased_prototype, obj-&gt;<span class="built_in">mark_addr</span>(), mark);</span><br><span class="line">        <span class="keyword">if</span> (res_mark == biased_value) &#123;</span><br><span class="line">          <span class="keyword">return</span> BIAS_REVOKED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递增偏向撤销计数</span></span><br><span class="line">  HeuristicsResult heuristics = <span class="built_in">update_heuristics</span>(<span class="built_in">obj</span>(), attempt_rebias);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (heuristics == HR_NOT_BIASED) &#123;</span><br><span class="line">    <span class="comment">// 如果锁对象已经不是偏向状态了，就返回 NOT_BIASED，前面提到的轻量级锁竞争的情况将会在这里退出</span></span><br><span class="line">    <span class="keyword">return</span> NOT_BIASED;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (heuristics == HR_SINGLE_REVOKE) &#123;</span><br><span class="line">    Klass *k = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    markOop prototype_header = k-&gt;<span class="built_in">prototype_header</span>();</span><br><span class="line">    <span class="keyword">if</span> (mark-&gt;<span class="built_in">biased_locker</span>() == THREAD &amp;&amp;</span><br><span class="line">        prototype_header-&gt;<span class="built_in">bias_epoch</span>() == mark-&gt;<span class="built_in">bias_epoch</span>()) &#123;</span><br><span class="line">      <span class="comment">// 奇怪的分支情况：锁对象的 markword 是偏向自己的，且 epoch 也未过期</span></span><br><span class="line">      <span class="comment">// 据说是处理偏向锁对象调用过 hashCode 的情况（这里不用关心）</span></span><br><span class="line">      <span class="comment">// 既然是当前线程要撤销自己，那就不需要麻烦 VM 线程了，当前线程自己处理即可</span></span><br><span class="line">      ResourceMark rm;</span><br><span class="line">      <span class="keyword">if</span> (TraceBiasedLocking) &#123;</span><br><span class="line">        tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Revoking bias by walking my own stack:&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      BiasedLocking::Condition cond = <span class="built_in">revoke_bias</span>(<span class="built_in">obj</span>(), <span class="literal">false</span>, <span class="literal">false</span>, (JavaThread*) THREAD);</span><br><span class="line">      ((JavaThread*) THREAD)-&gt;<span class="built_in">set_cached_monitor_info</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">assert</span>(cond == BIAS_REVOKED, <span class="string">&quot;why not?&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> cond;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// case 1</span></span><br><span class="line">      <span class="comment">// 绝大多数情况应该是进入这个分支，当前线程要偏向撤销，且期间没有发生批量重偏向以及批量撤销等情况</span></span><br><span class="line">      <span class="comment">// 锁对象偏向于线程 A，当前线程是线程 B，将偏向撤销操作交给 VM 线程去执行</span></span><br><span class="line">      <span class="comment">// 下面代码最终会在 VM 线程中的 safepoint 调用 revoke_bias 方法进行偏向撤销操作</span></span><br><span class="line">      VM_RevokeBias <span class="built_in">revoke</span>(&amp;obj, (JavaThread*) THREAD);</span><br><span class="line">      VMThread::<span class="built_in">execute</span>(&amp;revoke);</span><br><span class="line">      <span class="comment">// 一般返回的都是 BIAS_REVOKED</span></span><br><span class="line">      <span class="keyword">return</span> revoke.<span class="built_in">status_code</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="built_in">assert</span>((heuristics == HR_BULK_REVOKE) ||</span><br><span class="line">         (heuristics == HR_BULK_REBIAS), <span class="string">&quot;?&quot;</span>);</span><br><span class="line">   <span class="comment">// case 2         </span></span><br><span class="line">   <span class="comment">// 当前线程的这次偏向撤销，正好让 Klass 的偏向撤销计数递增到了批量重偏向的阈值或批量撤销的阈值</span></span><br><span class="line">   <span class="comment">// 下面是执行批量重偏向或批量撤销的逻辑，最终会在 VM 线程的 safepoint 中调用 bulk_revoke_or_rebias_at_safepoint 来进行批量重偏向或批量撤销的逻辑</span></span><br><span class="line">  <span class="function">VM_BulkRevokeBias <span class="title">bulk_revoke</span><span class="params">(&amp;obj, (JavaThread*) THREAD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                (heuristics == HR_BULK_REBIAS),</span></span></span><br><span class="line"><span class="params"><span class="function">                                attempt_rebias)</span></span>;</span><br><span class="line">  VMThread::<span class="built_in">execute</span>(&amp;bulk_revoke);</span><br><span class="line">  <span class="comment">// 如果是 bulk_revoke 执行的是批量重偏向，返回 BIAS_REVOKED_AND_REBIASED</span></span><br><span class="line">  <span class="keyword">return</span> bulk_revoke.<span class="built_in">status_code</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>revoke_and_rebias</code> 包含了非常多种情况的处理，我们重点关注其中的后半部分 <code>case 1</code> 和 <code>case 2</code>。<code>case 1</code> 表示执行单次撤销的情况，<code>case 2</code> 表示批量撤销或批量重偏向的情况。</p>
<p>先来看看 <code>case 1</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="comment">// 创建了一个 VM_RevokeBias 类的实例，名为 revoke，后面是传入的构造函数的参数</span></span><br><span class="line"><span class="function">VM_RevokeBias <span class="title">revoke</span><span class="params">(&amp;obj, (JavaThread*) THREAD)</span></span>;</span><br><span class="line"><span class="comment">// 将 revoke 对象交给 VMThread 去执行</span></span><br><span class="line">VMThread::<span class="built_in">execute</span>(&amp;revoke);</span><br></pre></td></tr></table></figure>
<p>在 <code>HotSpot</code> 的内部实现中，有一系列的 VM 操作类，它们都继承自基类 <code>VM_Operation</code>。<code>VM_RevokeBias</code> 就是其中一个，它重写了基类的 <code>doit()</code> 方法，当调用 <code>VMThread::execute(&amp;revoke)</code> 时，VM 线程就会调用 <code>revoke</code> 的 <code>doit()</code> 方法来做具体操作，其中 <code>doit()</code> 方法内部就调用了 <code>revoke_bias()</code> 方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VM_RevokeBias</span> : <span class="keyword">public</span> VM_Operation &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Handle* _obj;</span><br><span class="line">  GrowableArray&lt;Handle&gt;* _objs;</span><br><span class="line">  JavaThread* _requesting_thread;</span><br><span class="line">  BiasedLocking::Condition _status_code;</span><br><span class="line">  traceid _biased_locker_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VM_RevokeBias</span>(Handle* obj, JavaThread* requesting_thread)</span><br><span class="line">    : _obj(obj)</span><br><span class="line">    , _objs(<span class="literal">NULL</span>)</span><br><span class="line">    , _requesting_thread(requesting_thread)</span><br><span class="line">    , _status_code(BiasedLocking::NOT_BIASED)</span><br><span class="line">    , _biased_locker_id(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (TraceBiasedLocking) &#123;</span><br><span class="line">        tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Revoking bias with potentially per-thread safepoint:&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      JavaThread* biased_locker = <span class="literal">NULL</span>;</span><br><span class="line">      <span class="comment">// 调用 revoke_bias，allow_rebias 参数是 false</span></span><br><span class="line">      _status_code = <span class="built_in">revoke_bias</span>((*_obj)(), <span class="literal">false</span>, <span class="literal">false</span>, _requesting_thread, &amp;biased_locker);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> INCLUDE_JFR</span></span><br><span class="line">      <span class="keyword">if</span> (biased_locker != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        _biased_locker_id = <span class="built_in">JFR_THREAD_ID</span>(biased_locker);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// INCLUDE_JFR</span></span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">clean_up_cached_monitor_info</span>();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (TraceBiasedLocking) &#123;</span><br><span class="line">        tty-&gt;<span class="built_in">print_cr</span>(<span class="string">&quot;Revoking bias with global safepoint:&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      BiasedLocking::<span class="built_in">revoke_at_safepoint</span>(_objs);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br></pre></td></tr></table></figure>
<p>接下来重点分析一下 <code>revoke_bias</code> 方法。<br><code>revoke_bias</code> 方法一般是 VM 线程来执行，该方法虽然名字上看是叫撤销偏向，但却接收一个 <code>allow_rebias</code> 参数：</p>
<ul>
<li>该参数绝大多数情况下都是 <code>false</code>，比如上面的 <code>case 1</code> 中 <code>VMThread::execute(&amp;revoke)</code> 去做单次撤销，以及后面的 <code>case 2</code> 中的 <code>VMThread::execute(&amp;bulk_revoke)</code> 去做批量撤销。<code>allow_rebias == false</code> 的情况下 <code>revoke_bias</code> 方法必然是去执行偏向撤销的操作。</li>
<li>一般为 <code>true</code> 只存在一种情况，与 <code>case 2</code> 中的 <code>VMThread::execute(&amp;bulk_revoke)</code> 去做批量重偏向有关，后面会提到。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> BiasedLocking::Condition <span class="title">revoke_bias</span><span class="params">(oop obj, <span class="type">bool</span> allow_rebias, <span class="type">bool</span> is_bulk, JavaThread* requesting_thread)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="keyword">if</span> (!mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果锁对象已经是非偏向状态，直接返回 NOT_BIASED（不是重点）</span></span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint age = mark-&gt;<span class="built_in">age</span>();</span><br><span class="line">  <span class="comment">// 构建两个 markword，一个是匿名偏向模式（101），一个是无锁模式（001）</span></span><br><span class="line">  markOop   biased_prototype = markOopDesc::<span class="built_in">biased_locking_prototype</span>()-&gt;<span class="built_in">set_age</span>(age);</span><br><span class="line">  markOop unbiased_prototype = markOopDesc::<span class="built_in">prototype</span>()-&gt;<span class="built_in">set_age</span>(age);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  JavaThread* biased_thread = mark-&gt;<span class="built_in">biased_locker</span>();</span><br><span class="line">  <span class="keyword">if</span> (biased_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">// 奇怪的分支</span></span><br><span class="line">     <span class="comment">// 据说 biased_thread == NULL 表示匿名偏向</span></span><br><span class="line">     <span class="comment">// 据说是处理偏向锁对象调用过 hashCode 的情况（这里不用关心）</span></span><br><span class="line">    <span class="keyword">if</span> (!allow_rebias) &#123;</span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断锁对象偏向的线程是否还存活</span></span><br><span class="line">  <span class="type">bool</span> thread_is_alive = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 如果请求的线程就是偏向线程（当前线程是 VM 线程，请求的线程指的是希望执行偏向撤销的某个 Java 线程）</span></span><br><span class="line">  <span class="keyword">if</span> (requesting_thread == biased_thread) &#123;</span><br><span class="line">    thread_is_alive = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 遍历当前 jvm 的所有 java 线程，如果能找到，则说明偏向的线程还存活</span></span><br><span class="line">    <span class="keyword">for</span> (JavaThread* cur_thread = Threads::<span class="built_in">first</span>(); cur_thread != <span class="literal">NULL</span>; cur_thread = cur_thread-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cur_thread == biased_thread) &#123;</span><br><span class="line">        thread_is_alive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果偏向的线程已经不存活了</span></span><br><span class="line">  <span class="keyword">if</span> (!thread_is_alive) &#123;</span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">      <span class="comment">// 批量重偏向的情况：如果允许重偏向，那么就将锁对象的 markword 恢复为匿名偏向状态</span></span><br><span class="line">      <span class="comment">// 注意，这里只是恢复到匿名偏向，还没有重偏向到某个具体线程</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 单次偏向撤销 或 批量撤销的情况：否则将所对象 mark word 设置为无锁状态</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果偏向的线程还存活，则到偏向的线程的线程栈中遍历所有的 LockRecord</span></span><br><span class="line">  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = <span class="built_in">get_or_compute_monitor_info</span>(biased_thread);</span><br><span class="line">  BasicLock* highest_lock = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">    MonitorInfo* mon_info = cached_monitor_info-&gt;<span class="built_in">at</span>(i);</span><br><span class="line">    <span class="comment">// 如果能找到对应的 LockRecord 说明偏向的线程还在执行同步代码块中的代码</span></span><br><span class="line">    <span class="keyword">if</span> (mon_info-&gt;<span class="built_in">owner</span>() == obj) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 此时需要直接升级为轻量级锁，直接修改偏向线程栈中的相关的 LockRecord。</span></span><br><span class="line">      <span class="comment">// 为了处理锁重入的情况，显式将每个 LockRecord 的 displaced markword 都先置为 null</span></span><br><span class="line">      <span class="comment">// 偏向线程栈中第一个相关的 LockRecord 会最后被遍历到，然后在后面还会再处理</span></span><br><span class="line">      markOop mark = markOopDesc::<span class="built_in">encode</span>((BasicLock*) <span class="literal">NULL</span>);</span><br><span class="line">      highest_lock = mon_info-&gt;<span class="built_in">lock</span>();</span><br><span class="line">      highest_lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (highest_lock != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 对于第一个相关的 LockRecord，需要将其 displaced markword 置为无锁状态</span></span><br><span class="line">    <span class="comment">// 同时将第一个相关的 LockRecord 的地址设置到锁对象的 markword，自此偏向锁就完成了到轻量级锁的升级</span></span><br><span class="line">    highest_lock-&gt;<span class="built_in">set_displaced_header</span>(unbiased_prototype);</span><br><span class="line">    obj-&gt;<span class="built_in">release_set_mark</span>(markOopDesc::<span class="built_in">encode</span>(highest_lock));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 走到这里说明偏向线程虽然存活，但是并不在同步块中</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (allow_rebias) &#123;</span><br><span class="line">       <span class="comment">// 批量重偏向的情况：如果允许重偏向，那么就将锁对象的 markword 恢复为匿名偏向状态</span></span><br><span class="line">       <span class="comment">// 注意，这里只是恢复到匿名偏向，还没有重偏向到某个具体线程</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(biased_prototype);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 单次偏向撤销 或 批量撤销的情况：否则将所对象 mark word 设置为无锁状态</span></span><br><span class="line">      obj-&gt;<span class="built_in">set_mark</span>(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> BiasedLocking::BIAS_REVOKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>case 1</code> 的场景而言，<code>revoke_bias</code> 只存在单次偏向撤销的情况：<br>如果锁对象偏向的线程 A 已经不存活，那么就直接将锁对象设置为无锁状态<br>如果锁对象偏向的线程 A 还存活，但是并不活跃（正在持有锁执行同步代码块），也是直接将锁对象设置为无锁状态<br>如果锁对象偏向的线程 A 存活且活跃，锁对象将直接升级为轻量级锁（这里处理时，需要考虑锁重入的情况）</p>
<p>我们再回过头来看 <code>case 2</code> 的情况，也就是批量撤销或批量重偏向的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="comment">// 创建了一个 VM_BulkRevokeBias 类的实例，命名为 bulk_revoke，后面是传入的构造函数的参数</span></span><br><span class="line"><span class="function">VM_BulkRevokeBias <span class="title">bulk_revoke</span><span class="params">(&amp;obj, (JavaThread*) THREAD,</span></span></span><br><span class="line"><span class="params"><span class="function">                                (heuristics == HR_BULK_REBIAS),</span></span></span><br><span class="line"><span class="params"><span class="function">                                attempt_rebias)</span></span>;</span><br><span class="line"><span class="comment">// 将 bulk_revoke 对象交给 VMThread 去执行</span></span><br><span class="line">VMThread::<span class="built_in">execute</span>(&amp;bulk_revoke);</span><br></pre></td></tr></table></figure>
<p>在 <code>revoke_and_rebias</code> 方法中执行了一次 <code>update_heuristics</code> 来递增偏向撤销的计数，该该方法的返回值很关键：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HeuristicsResult heuristics = <span class="built_in">update_heuristics</span>(<span class="built_in">obj</span>(), attempt_rebias);</span><br></pre></td></tr></table></figure>
<p>如果偏向撤销计数达到了批量撤销的阈值，那么返回值就是 <code>HR_BULK_REVOKE</code><br>如果偏向撤销计数达到的是批量重偏向的阈值，那么返回值就是 <code>HR_BULK_REBIAS</code></p>
<p>在构造 <code>VM_BulkRevokeBias</code> 对象实例时，传入的第三个参数 <code>(heuristics == HR_BULK_REBIAS)</code> 就能够根据 <code>update_heuristics</code> 返回值的不同，最终让 VM 线程去执行批量撤销或者批量重偏向。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VM_BulkRevokeBias 继承了 VM_RevokeBias，从而也是 VM_Operation 的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VM_BulkRevokeBias</span> : <span class="keyword">public</span> VM_RevokeBias &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">bool</span> _bulk_rebias;</span><br><span class="line">  <span class="type">bool</span> _attempt_rebias_of_object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VM_BulkRevokeBias</span>(Handle* obj, JavaThread* requesting_thread,</span><br><span class="line">                    <span class="type">bool</span> bulk_rebias,</span><br><span class="line">                    <span class="type">bool</span> attempt_rebias_of_object)</span><br><span class="line">    : <span class="built_in">VM_RevokeBias</span>(obj, requesting_thread)</span><br><span class="line">    , _bulk_rebias(bulk_rebias)</span><br><span class="line">    , _attempt_rebias_of_object(attempt_rebias_of_object) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> VMOp_Type <span class="title">type</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> VMOp_BulkRevokeBias; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">doit_prologue</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">doit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bulk_revoke_or_rebias_at_safepoint 方法被调用</span></span><br><span class="line">    <span class="comment">// _bulk_rebias 为 true 表示执行批量重偏向，为 false 表示执行批量撤销</span></span><br><span class="line">    <span class="comment">// _attempt_rebias_of_object 一般为 true，表示允许重偏向</span></span><br><span class="line">    _status_code = <span class="built_in">bulk_revoke_or_rebias_at_safepoint</span>((*_obj)(), _bulk_rebias, _attempt_rebias_of_object, _requesting_thread);</span><br><span class="line">    <span class="built_in">clean_up_cached_monitor_info</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来重点分析一下 <code>bulk_revoke_or_rebias_at_safepoint</code> 方法。<br><code>bulk_revoke_or_rebias_at_safepoint</code> 在命名上就已经反映了，该方法一般是 VM 线程来执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> BiasedLocking::Condition <span class="title">bulk_revoke_or_rebias_at_safepoint</span><span class="params">(oop o,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                   <span class="type">bool</span> bulk_rebias,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                   <span class="type">bool</span> attempt_rebias_of_object,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                   JavaThread* requesting_thread)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  jlong cur_time = os::<span class="built_in">javaTimeMillis</span>();</span><br><span class="line">  o-&gt;<span class="built_in">klass</span>()-&gt;<span class="built_in">set_last_biased_lock_bulk_revocation_time</span>(cur_time);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Klass* k_o = o-&gt;<span class="built_in">klass</span>();</span><br><span class="line">  Klass* klass = k_o;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (bulk_rebias) &#123;</span><br><span class="line">    <span class="comment">// 批量重偏向的逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">      <span class="comment">// 自增 Klass 中的 epoch</span></span><br><span class="line">      <span class="type">int</span> prev_epoch = klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">bias_epoch</span>();</span><br><span class="line">      klass-&gt;<span class="built_in">set_prototype_header</span>(klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">incr_bias_epoch</span>());</span><br><span class="line">      <span class="type">int</span> cur_epoch = klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">bias_epoch</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历 JVM 所有线程栈，找出所有目前正在“活跃”的类型为 Klass 的偏向锁对象，让这些对象的 epoch 与 Klass 的 epoch 保持一致</span></span><br><span class="line">      <span class="comment">// 这里的“活跃”我打了双引号，因为有一部分偏向锁对象可能其实并没有处在锁定状态</span></span><br><span class="line">      <span class="keyword">for</span> (JavaThread* thr = Threads::<span class="built_in">first</span>(); thr != <span class="literal">NULL</span>; thr = thr-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">        GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = <span class="built_in">get_or_compute_monitor_info</span>(thr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">          MonitorInfo* mon_info = cached_monitor_info-&gt;<span class="built_in">at</span>(i);</span><br><span class="line">          oop owner = mon_info-&gt;<span class="built_in">owner</span>();</span><br><span class="line">          markOop mark = owner-&gt;<span class="built_in">mark</span>();</span><br><span class="line">          <span class="keyword">if</span> ((owner-&gt;<span class="built_in">klass</span>() == k_o) &amp;&amp; mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">            <span class="comment">// We might have encountered this object already in the case of recursive locking</span></span><br><span class="line">            <span class="built_in">assert</span>(mark-&gt;<span class="built_in">bias_epoch</span>() == prev_epoch || mark-&gt;<span class="built_in">bias_epoch</span>() == cur_epoch, <span class="string">&quot;error in bias epoch adjustment&quot;</span>);</span><br><span class="line">            owner-&gt;<span class="built_in">set_mark</span>(mark-&gt;<span class="built_in">set_bias_epoch</span>(cur_epoch));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就是之前提到的，调用 revoke_bias 是 attempt_rebias 参数唯一为 true 的情况</span></span><br><span class="line">    <span class="comment">// 如果偏向锁对象目前活跃，那么这里会直接将偏向锁升级为轻量级锁</span></span><br><span class="line">    <span class="comment">// 如果偏向锁对象目前不活跃，那么这里会将偏向锁对象会重置为匿名偏向状态，而不是直接重偏向到请求的线程，可以说这里是只做了一半的重偏向，真正重偏向到请求线程是在本方法末尾</span></span><br><span class="line">    <span class="built_in">revoke_bias</span>(o, attempt_rebias_of_object &amp;&amp; klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="literal">true</span>, requesting_thread);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 批量撤销的逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 将 Klass 中的偏向标记关闭，markOopDesc::prototype() 返回的是一个关闭偏向模式的 prototype</span></span><br><span class="line">    klass-&gt;<span class="built_in">set_prototype_header</span>(markOopDesc::<span class="built_in">prototype</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 JVM 所有线程栈，找出所有目前正在“活跃”的类型为 Klass 的偏向锁对象，升级为轻量级锁</span></span><br><span class="line">    <span class="comment">// 这里的“活跃”我打了双引号，因为有一部分偏向锁对象可能其实并没有处在锁定状态</span></span><br><span class="line">    <span class="keyword">for</span> (JavaThread* thr = Threads::<span class="built_in">first</span>(); thr != <span class="literal">NULL</span>; thr = thr-&gt;<span class="built_in">next</span>()) &#123;</span><br><span class="line">      GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = <span class="built_in">get_or_compute_monitor_info</span>(thr);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cached_monitor_info-&gt;<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        MonitorInfo* mon_info = cached_monitor_info-&gt;<span class="built_in">at</span>(i);</span><br><span class="line">        oop owner = mon_info-&gt;<span class="built_in">owner</span>();</span><br><span class="line">        markOop mark = owner-&gt;<span class="built_in">mark</span>();</span><br><span class="line">        <span class="keyword">if</span> ((owner-&gt;<span class="built_in">klass</span>() == k_o) &amp;&amp; mark-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">          <span class="built_in">revoke_bias</span>(owner, <span class="literal">false</span>, <span class="literal">true</span>, requesting_thread);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这一步其实是冗余的，在刚刚上面的双层 for 循环内部就处理过了：revoke_bias(owner, false, true, requesting_thread)</span></span><br><span class="line">    <span class="comment">// 双层 for 循环中 owner == o 的情况是存在的</span></span><br><span class="line">    <span class="built_in">revoke_bias</span>(o, <span class="literal">false</span>, <span class="literal">true</span>, requesting_thread);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  BiasedLocking::Condition status_code = BiasedLocking::BIAS_REVOKED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (attempt_rebias_of_object &amp;&amp;</span><br><span class="line">      o-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>() &amp;&amp;</span><br><span class="line">      klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">    <span class="comment">// 如果上面执行的是批量重偏向，有可能进入该分支</span></span><br><span class="line">    <span class="comment">// 批量重偏向在双层 for 循环后做了一个 revoke_rebias，当偏向锁对象不活跃时，会将其置为匿名重偏向，而没有重偏向到请求线程，这里就是真正重偏向到请求线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个偏向请求线程的 markword</span></span><br><span class="line">    markOop new_mark = markOopDesc::<span class="built_in">encode</span>(requesting_thread, o-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">age</span>(),</span><br><span class="line">                                           klass-&gt;<span class="built_in">prototype_header</span>()-&gt;<span class="built_in">bias_epoch</span>());</span><br><span class="line">    <span class="comment">// 更新当前锁对象的 markword</span></span><br><span class="line">    o-&gt;<span class="built_in">set_mark</span>(new_mark);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这种情况下，也会返回 BIAS_REVOKED_AND_REBIASED</span></span><br><span class="line">    <span class="comment">// 回顾一下就是，线程 B 希望做偏向撤销操作，结果恰好这次就触发了批量重偏向</span></span><br><span class="line">    <span class="comment">// 对于触发批量重偏向的请求线程 B，会尝试为其做一次重偏向，如果偏向锁不活跃，就会成功重偏向</span></span><br><span class="line">    <span class="comment">// 这样，线程 B 就获取到了偏向锁，后续回到前面 fast_enter 中就可以直接退出，而不是进入 slow_enter 去尝试获取轻量级锁</span></span><br><span class="line">    status_code = BiasedLocking::BIAS_REVOKED_AND_REBIASED;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status_code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的批量重偏向以及批量撤销操作中，都涉及到了一个遍历线程栈，所有目前正在“活跃”的类型为 Klass 的偏向锁对象的操作，为什么我这里的“活跃”打了个引号呢？</p>
<p>先下定义：活跃状态指的是，偏向锁对象目前处在锁定状态，也即所偏向的线程正在执行同步代码块的状态。</p>
<p>但其实存在一些偏向锁对象，它并没有在执行同步代码块，却也被批量重偏向和批量撤销操作处理了。</p>
<p>举个简单的例子，线程 B 去访问偏向锁，发现偏向的是线程 A，即使线程 A 此时没有在执行相应的同步代码块，即在线程 A 的线程栈中找不到关联偏向锁的 <code>LockRecord</code>，但由于只要从偏向锁的入口进入就会在相应的线程栈中创建一个 <code>LockRecord</code> 并与偏向锁关联，所以线程 B 的栈中会存在一个关联偏向锁的 <code>LockRecord</code>，导致偏向锁明明没有被锁定却会被处理！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CASE</span>(_monitorenter): &#123;</span><br><span class="line">  <span class="comment">// lockee 就是锁对象</span></span><br><span class="line">  oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">CHECK_NULL</span>(lockee);</span><br><span class="line">  <span class="comment">// 在当前线程栈找到一个空闲的 Lock Record</span></span><br><span class="line">  BasicObjectLock* limit = istate-&gt;<span class="built_in">monitor_base</span>();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="built_in">stack_base</span>();</span><br><span class="line">  BasicObjectLock* entry = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (most_recent-&gt;<span class="built_in">obj</span>() == <span class="literal">NULL</span>) entry = most_recent;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (most_recent-&gt;<span class="built_in">obj</span>() == lockee) <span class="keyword">break</span>;</span><br><span class="line">    most_recent++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (entry != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到以后，将 LockRecord 的 obj 指针指向锁对象，完成关联</span></span><br><span class="line">    entry-&gt;<span class="built_in">set_obj</span>(lockee);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下，批量重偏向以及批量撤销可能“误伤”了一些不在锁定状态的偏向锁对象：</p>
<ul>
<li>批量重偏向的误伤：不活跃的锁对象也更新 <code>epoch</code>，而不是让它过期</li>
<li>批量撤销的误伤：不活跃的锁对象被撤销偏向，被修改为无锁状态</li>
</ul>
<p>这也是我说批量撤销分支最后的那个 <code>revoke_bias</code> 是冗余的原因了。</p>
<p>想要避免“误伤”的话，其实源码里面略作改动即可，也即遍历所有线程栈，如果找到一个 <code>LockRecord</code> 其 <code>obj</code> 指向了一个偏向锁对象（对象为 <code>Klass</code> 类型）后，额外再到偏向锁对象所偏向的线程的栈中再检查是否存在关联的 <code>LockRecord</code>。但这样的话，就变成了三层循环，可能导致性能的下降。</p>
<p>至此，我们总算是将偏向锁撤销的完整流程走通了。</p>
<h4 id="为什么偏向撤销一般是需要在-safepoint-期间来完成的？"><a href="#为什么偏向撤销一般是需要在-safepoint-期间来完成的？" class="headerlink" title="为什么偏向撤销一般是需要在 safepoint 期间来完成的？"></a>为什么偏向撤销一般是需要在 <code>safepoint</code> 期间来完成的？</h4><p>假设偏向锁对象正在被线程 A 使用，线程 B 此时也来获取锁，在线程 B 的视角下，它知道目前锁对象已经偏向了线程 A，需要进行偏向撤销操作。</p>
<ul>
<li>偏向撤销操作需要根据锁对象是否活跃来做不同的处理。<br> 然而线程 B 根本无法确定锁对象是否活跃。要确定锁对象是否活跃，线程 B 必须要访问线程 A 的栈空间看看有没有对应的 <code>LockRecord</code>，这是不可能的，JVM 中每个线程的栈空间都是线程私有的。</li>
<li>就算线程 B 开了天眼知道锁对象是活跃的，即线程 A 正在执行同步代码块，线程 B 也无法执行活跃情况下的偏向撤销处理。<br>偏向锁活跃，此时要做偏向撤销是升级为轻量级锁：锁对象的 <code>markword</code> 需要设置为指向线程 A 中的第一个 <code>LockRecord</code> 的地址。但是线程 B 不可能访问线程 A 的栈空间，也就无法得到线程 A 中的第一个 <code>LockRecord</code> 的地址。</li>
</ul>
<p>于是线程 B 只能偏向撤销的操作交给 VM 线程来完成。</p>
<p>到了 <code>safepoint</code> 期间，所有 Java 线程都停止工作，VM 线程开始活动。<br>VM 线程可以访问所有 Java 线程，自然就可以到线程 A 中去检查栈中是否有指向该偏向锁对象的 <code>LockRecord</code>，如果有就说明偏向锁活跃，线程 A 还在执行同步代码块，否则就是不活跃，线程 A 已经释放了偏向锁。根据活跃状态的不同，VM 线程就可以去做不同的处理了：</p>
<ul>
<li>偏向锁对象活跃，VM 线程此时找到线程 A 的栈中最早的那个 <code>LockRecord</code>，将其 <code>displaced markword</code> 设置为无锁状态，将其他的 <code>LockRecord</code> 的 <code>displaced markword</code> 设置为 <code>NULL</code>，然后将该 <code>LockRecord</code> 的地址设置到偏向锁对象的 <code>markword</code> 中去，从而直接完成偏向锁到轻量级锁的升级。注意，这里的处理是兼顾了锁重入的情况。</li>
<li>偏向锁对象不活跃，或者偏向线程已死的情况，直接将偏向锁对象的 <code>markword</code> 设置为无锁状态，从而完成偏向锁到无锁状态的转换。</li>
</ul>
<h4 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h4><p>每次执行偏向撤销，都会将偏向锁对象所属的 <code>Klass</code> 类信息中的 <code>revocation_count</code> 加一。</p>
<p>一旦 <code>revocation_count</code> 到达 <code>BiasedLockingBulkRebiasThreshold</code> 批量重偏向阈值（一般是 20），就执行批量重偏向操作。</p>
<p>批量重偏向这个命名具有一定的迷惑性，初学者容易误以为，批量重偏向是立即完成的。<br>其实稍微想一下，就知道批量重偏向是不可能立即完成的，我们无法预知未来！</p>
<p>从批量重偏向的实际操作逻辑来看，其实真正将某个偏向锁的 <code>markword</code> 中的 <code>threadId</code> 偏向于新线程，是要等到下次线程来获取偏向锁时才发生的，因此批量重偏向，可以理解为是批量打上可重偏向标记。</p>
<p><code>Klass</code> 可能有非常多的对象实例，在批量重偏向后，那些在批量重偏向时不活跃的偏向锁对象，就被打上一个可重偏向标记。<br>如果一个偏向锁对象带有该标记，就说明该对象目前一定是没有线程在使用的，即没有线程正在执行相应的同步代码块。这样下次有线程来获取该对象时，看到有可重偏向标记，就可以放心的执行 <code>cas</code> 操作，将自己的线程 id 设置到该对象的 <code>markword</code> 中来完成重偏向，无需担心是否会影响到其他线程。这里也可能是重偏向给自己，但无论是重偏向给谁，重偏向发生过后，被打上的可重偏向标记也随着 <code>cas</code> 操作被清除掉了。<br>至于那些批量重偏向时还活跃的对象，由于所偏向的线程还在使用它们，因此它们本就不具备可重偏向的条件，自然就不会被打上可重偏向的标记，后续如果其他线程来访问，应该将进入偏向撤销的逻辑。</p>
<p>“批量重偏向是为那些批量重偏向时不活跃的偏向锁对象，打上一个可重偏向标记”，这其实一种便于理解的说法。实际上，批量重偏向主要做了两件事：</p>
<ul>
<li>先将 <code>Klass</code> 类信息中的 <code>epoch</code> 加一。</li>
<li>然后找出 <code>Klass</code> 所有目前正在“活跃”的偏向锁对象，让其 <code>epoch</code> 与 <code>Klass</code> 类信息的 <code>epoch</code> 保持一致。</li>
</ul>
<p>可以看到，其实批量重偏向压根就没有去操作那些不“活跃”的偏向锁对象，而是反过来去操作那些“活跃”的偏向锁对象。但正因为没有操作，所有这些不活跃对象的 <code>epoch</code> 肯定是过期的，与 <code>Klass</code> 类信息中的 <code>epoch</code> 不一致的。这种不一致，其实是就相当于是一种可重偏向标记。</p>
<p>当下次有线程来获取该对象的偏向锁时，会先检查 <code>epoch</code> 是否过期，如果已过期，则认为是打上了可重偏向标记的不活跃对象，直接进行 <code>cas</code> 操作更新 <code>epoch</code> 和 <code>threadId</code>。</p>
<h4 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h4><p>针对于某个 <code>Klass</code> 的批量重偏向发生后，系统就会记录这个批量重偏向的时间，如果这个 <code>Klass</code> 的对象实例，在接下来的指定时间内 <code>BiasedLockingDecayTime</code>（一般是 25 秒），发生了多次偏向撤销操作，导致 <code>revocation_count</code> 超过了批量撤销的阈值 <code>BiasedLockingBulkRevokeThreshold</code>（一般是 40），此时就会进行批量撤销。</p>
<p>一般来说，<code>revocation_count</code> 在批量重偏向后为 20，如果在批量重偏向后的 25 秒内，到达了 40，就触发批量撤销操作；否则就重置 <code>revocation_count</code> 为 0，从而为下次批量重偏向提供可能。</p>
<p>批量撤销主要做了两件件事：</p>
<ul>
<li>标记 <code>Klass</code> 为不可偏向，具体是修改 <code>Klass</code> 中的 <code>prototype_header</code> 为不可偏向模式。</li>
<li>找出 <code>Klass</code> 所有目前正在“活跃”的偏向锁对象，逐个执行偏向撤销操作<ul>
<li>真正活跃的处于锁定状态的，会升级为轻量级锁</li>
<li>实际不活跃的未处于锁定状态的，会修改为无锁</li>
</ul>
</li>
</ul>
<p>批量撤销后，如果创建了 <code>Klass</code> 的新对象实例，那么这些新对象实例创建出来就是不可偏向的无锁状态，即 <code>markword</code> 的后三位是 <code>001</code>，后续线程来加锁时是直接加轻量级锁，而不会进入加偏向锁的逻辑。</p>
<p>而对于那些批量撤销前，已经创建出来的 <code>Klass</code> 的旧对象实例：</p>
<ul>
<li>如果对象实例已经是无锁/轻量级锁/重量级锁状态，根本不会收到批量撤销的影响。<br>批量撤销本质是对处于偏向状态的那些对象，逐个执行单次偏向撤销操作！</li>
<li>如果对象实例是偏向锁状态，此时具体可分为两类：<ul>
<li>批量撤销时正“活跃”的对象，遍历所有 Java 线程栈空间能找到对应 <code>LockRecord</code> 的：如上面所说，真正活跃的会升级为轻量级锁，实际不活跃但被误以为活跃的，会修改为无锁</li>
<li>确实不活跃的对象，遍历所有 Java 线程栈空间都找不到对应的 <code>LockRecord</code> 的，这一类对象在重新活跃时，可能受到影响：<ul>
<li><code>epoch</code> 没过期且偏向的是当前线程，则不受影响，后续直接进入同步代码块，锁对象依然是偏向锁</li>
<li>其他情况，包括 <code>epoch</code> 过期，匿名偏向状态，或者不是偏向当前线程的，会直接 <code>cas</code> 关闭锁对象的偏向模式，置为无锁状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>题外话：批量撤销时，为什么不干脆再把那些确实不活跃的偏向锁对象也一并处理为无锁呢？</p>
<p>个人认为，可能是处于以下的考虑：</p>
<ul>
<li><p>主要原因是，“活跃”的偏向锁对象容易定位到。<br>每个“活跃”的偏向锁对象必然在某个 Java 线程的栈中存在一个 <code>LockRecord</code> 与之关联，遍历 JVM 所有线程栈中的 <code>LockRecord</code>，如果某个 <code>LockRecord</code> 的 <code>obj</code> 字段指向了给定 <code>Klass</code> 类型的对象，那么这个对象就是“活跃”的偏向锁对象。<br>而确实不活跃的偏向锁对象就麻烦了，无法通过 <code>LockReocrd</code> 机制来指引，要找到这些类型为 <code>Klass</code> 的对象实例可能需要遍历整个堆，这无疑是非常耗时的，会极大延长批量撤销时的 <code>safepoint</code> 时间！</p>
</li>
<li><p>确实不活跃的偏向锁对象可能非常多，且可能以后都不会使用了，在宝贵的 <code>safepoint</code> 时间下立即对它们处理性价比不高。<br>要知道，在开启偏向锁的情况下，每个 Java 对象被创建时都默认是匿名偏向状态，可见不活跃的偏向锁对象一定是很多的！但其中绝大多数可能以后都不会使用了，在宝贵的 <code>safepoint</code> 时间下立即对它们处理性价比不高，让这些不活跃对象后续重新活跃时再处理，是种高效且自然的做法。</p>
</li>
<li><p>确实不活跃的偏向锁对象虽然在批量撤销中没有直接处理，但它们都隐式地带上了一个不活跃的标记，这个标记的存在保证了不活跃对象后续重新活跃时，再进行偏向撤销操作会非常容易。<br>一般的偏向撤销操作是需要等到 <code>safepoint</code> 去执行的。如果能确定锁对象是不活跃的，那么偏向撤销操作其实根本就无需等到 <code>safepoint</code>，直接 <code>case</code> 将锁对象的 <code>markword</code> 设为无锁状态即可。<br>恰好，批量撤销后，所有活跃的偏向锁对象都在批量撤销期间已被处理，JVM 中剩余的 <code>Klass</code> 偏向锁对象都必然是不活跃的！这就是所谓的隐式地带上了一个不活跃的标记。<br>既然不活跃对象在非 <code>safepoint</code> 的情况下也能很方便处理，那何必浪费宝贵的 <code>safepoint</code> 时间呢，而且重新活跃再处理，不活跃就一直不处理，显然是更高效的做法。</p>
</li>
</ul>
<p>出于类似的考虑，批量重偏向中也是处理那些活跃的偏向锁对象。</p>
<hr>
<p>题外话：批量撤销可不可以只将 <code>Klass</code> 标记为不可偏向就结束，而不去处理那些活跃的偏向锁对象呢？这样批量撤销时的 <code>safepoint</code> 就更短了。</p>
<p>如果不去处理那些活跃的偏向锁对象，那么批量撤销后 JVM 中剩余的 <code>Klass</code> 偏向锁对象有可能是活跃的，也有可能是不活跃的，此时任意一个对象后续需要偏向撤销时，由于不确定它是否是活跃的，就需要等到 <code>safepoint</code> 才能去完成偏向撤销操作。</p>
<p>因此，批量撤销所在的 <code>safepoint</code> 时间可能是短了，但是省下来的时间其实是被转移到了后续多个 <code>safepoint</code> 中了。与其让将这些偏向锁对象放到后续的往往是多个 <code>safepoint</code> 来分批做偏向撤销，倒不如直接就在这次 <code>safepoint</code> 期间就批量进行偏向撤销。</p>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><h4 id="轻量级锁的锁重入"><a href="#轻量级锁的锁重入" class="headerlink" title="轻量级锁的锁重入"></a>轻量级锁的锁重入</h4><p><img src="/img/itheima-juc/轻量级锁的锁重入示意图.svg" alt=""></p>
<h4 id="为什么-Hotspot-选择在线程栈中添加多个-LockRecord-来表示锁重入？"><a href="#为什么-Hotspot-选择在线程栈中添加多个-LockRecord-来表示锁重入？" class="headerlink" title="为什么 Hotspot 选择在线程栈中添加多个 LockRecord 来表示锁重入？"></a>为什么 Hotspot 选择在线程栈中添加多个 <code>LockRecord</code> 来表示锁重入？</h4><blockquote>
<p>一个简单的方案是将锁重入次数记录在对象头的<code>mark word</code>中，但<code>mark word</code>的大小是有限的，已经存放不下该信息了。<br>另一个方案是只创建一个<code>Lock Record</code>并在其中记录重入次数，Hotspot没有这样做的原因我猜是考虑到效率有影响：每次重入获得锁都需要遍历该线程的栈找到对应的<code>Lock Record</code>，然后修改它的值。</p>
</blockquote>
<p>目前 <code>Hotspot</code> 的用多个 <code>LockRecord</code> 表示锁重入的做法，每次获取锁和释放锁，一样是需要遍历线程的栈去找对应的 <code>LockRecord</code>。</p>
<p>个人猜测，可能和效率关系不大，实现方便应该是主要因素：特别是要考虑轻量级锁升级到重量级锁的逻辑。</p>
<h4 id="ObjectSynchronizer-slow-enter-补充分析"><a href="#ObjectSynchronizer-slow-enter-补充分析" class="headerlink" title="ObjectSynchronizer::slow_enter 补充分析"></a><code>ObjectSynchronizer::slow_enter</code> 补充分析</h4><p>前面分析偏向锁撤销流程时，我们简单分析过 <code>fast_enter</code> 和 <code>slow_enter</code>，但重点是放在 <code>fast_enter</code> 上。现在我们重点看 <code>slow_enter</code>。</p>
<p>进入 <code>slow_enter</code> 存在非常多种情况，我们关注那些具有代表性的，能串通锁升级流程的情况：</p>
<ul>
<li>锁一开始是偏向锁，偏向于线程 A，<strong>当前线程 B 获取偏向锁失败</strong>，执行偏向撤销<ul>
<li>线程 B 执行偏向撤销时，线程 A 已不存活或未在同步代码块内，线程 B 偏向撤销将锁变为无锁状态，然后进入 <code>slow_enter</code></li>
<li>线程 B 执行偏向撤销时，线程 A 在同步代码块内，线程 B 偏向撤销将锁变为轻量级状态，然后进入 <code>slow_enter</code></li>
</ul>
</li>
<li>锁一开始是轻量级锁状态，被线程 A 持有，<strong>当前线程 B 尝试以轻量级锁方式获取锁，失败</strong>，跳过偏向撤销流程，进入 <code>slow_enter</code></li>
<li>锁一开始是轻量级锁状态，被线程 A 持有，线程 C 来获取轻量级锁失败，跳过偏向撤销流程，进入 <code>slow_enter</code> 执行锁膨胀。<strong>当前线程 B 尝试以轻量级锁方式获取锁，由于锁处于膨胀中，故失败</strong>，跳过偏向撤销流程，进入 <code>slow_enter</code></li>
<li>锁一开始是重量级锁状态，被线程 A 持有，<strong>当前线程 B 尝试以轻量级锁方式获取锁，由于锁已经膨胀为重量级锁，故失败</strong>，跳过偏向撤销流程，进入 <code>slow_enter</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::fast_enter</span><span class="params">(Handle obj, BasicLock* lock, <span class="type">bool</span> attempt_rebias, TRAPS)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SafepointSynchronize::<span class="built_in">is_at_safepoint</span>()) &#123;</span><br><span class="line">      <span class="comment">// 如果是 Java 线程，执行的是该分支（一般是这条分支）</span></span><br><span class="line">      <span class="comment">// revoke_and_rebias 方法中包含了非常多种情况的处理，主要可以分为三类</span></span><br><span class="line">      <span class="comment">// (1) 重偏向，返回 BIAS_REVOKED_AND_REBIASED </span></span><br><span class="line">      <span class="comment">// (2) 偏向撤销，返回 BIAS_REVOKED</span></span><br><span class="line">      <span class="comment">// (3) 锁对象不是偏向模式：可能是轻量级锁/锁膨胀/重量级锁，方法什么都不做，直接返回 NOT_BIASED</span></span><br><span class="line">      BiasedLocking::Condition cond = BiasedLocking::<span class="built_in">revoke_and_rebias</span>(obj, attempt_rebias, THREAD);</span><br><span class="line">      <span class="keyword">if</span> (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">         <span class="comment">// 重偏向是将锁对象重新偏向当前线程，这意味着当前线程成功获取到了偏向锁</span></span><br><span class="line">         <span class="comment">// 因此可以直接退出，不用进入最后的 slow_enter </span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是 VM 线程，执行的是该分支</span></span><br><span class="line">      <span class="built_in">assert</span>(!attempt_rebias, <span class="string">&quot;can not rebias toward VM thread&quot;</span>);</span><br><span class="line">      BiasedLocking::<span class="built_in">revoke_at_safepoint</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(!obj-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;biases should be revoked by now&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 进入 `slow_enter` 存在非常多种情况：只要不是重偏向，剩下的逻辑都会进入 slow_enter</span></span><br><span class="line"> <span class="built_in">slow_enter</span> (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们来分析一下 <code>slow_enter</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::slow_enter</span><span class="params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  markOop mark = obj-&gt;<span class="built_in">mark</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!mark-&gt;<span class="built_in">has_bias_pattern</span>(), <span class="string">&quot;should not see bias pattern here&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mark-&gt;<span class="built_in">is_neutral</span>()) &#123;</span><br><span class="line">    <span class="comment">// code 1：对象是无锁状态，升级为轻量级锁后就退出</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(mark);</span><br><span class="line">    <span class="keyword">if</span> (mark == (markOop) Atomic::<span class="built_in">cmpxchg_ptr</span>(lock, <span class="built_in">obj</span>()-&gt;<span class="built_in">mark_addr</span>(), mark)) &#123;</span><br><span class="line">      <span class="built_in">TEVENT</span> (slow_enter: release stacklock) ;</span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mark-&gt;<span class="built_in">has_locker</span>() &amp;&amp; THREAD-&gt;<span class="built_in">is_lock_owned</span>((address)mark-&gt;<span class="built_in">locker</span>())) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(lock != mark-&gt;<span class="built_in">locker</span>(), <span class="string">&quot;must not re-lock the same lock&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(lock != (BasicLock*)obj-&gt;<span class="built_in">mark</span>(), <span class="string">&quot;don&#x27;t relock with same BasicLock&quot;</span>);</span><br><span class="line">    <span class="comment">// code 2 奇怪的分支：对象是轻量级锁，且锁的持有者是当前线程，锁重入后就退出</span></span><br><span class="line">    lock-&gt;<span class="built_in">set_displaced_header</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前面所有处理都是再次检查，是否实际上并不存在多个线程的竞争，如果不存在就直接处理并返回，避免走到下面</span></span><br><span class="line">  <span class="comment">// code 3：走到这里说明已经是存在多个线程竞争锁了，需要膨胀为重量级锁，然后用当前线程去获取重量级锁</span></span><br><span class="line">  lock-&gt;<span class="built_in">set_displaced_header</span>(markOopDesc::<span class="built_in">unused_mark</span>());</span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, <span class="built_in">obj</span>())-&gt;<span class="built_in">enter</span>(THREAD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>slow_enter</code> 很简短，主要逻辑是：</p>
<ul>
<li>先最后再检查一下，是否实际上不存在多线程竞争的情况，是的话，直接处理并返回，避免锁膨胀为重量级锁<br>比如 <code>code 1</code> 处的无锁情况，典型情况是：一开始是偏向锁，偏向于线程 A，当前线程 B 获取偏向锁失败，执行偏向撤销操作时，线程 B 执行偏向撤销时，线程 A 已不存活或未在同步代码块内，线程 B 偏向撤销将锁变为无锁状态，线程 B 再去获取锁时实际上不存在竞争情况</li>
<li>前面没有返回的话，说明锁存在多线程竞争，此时将当前线程最开始申请的 <code>LockRecord</code> 的 <code>header</code> 标记为 <code>unused</code>，表示该 <code>LockRecord</code> 对应的加锁情况是，锁膨胀后拿到重量级锁 <code>Monitor</code> 去加锁的。这个 <code>unused</code> 标记在解锁时将会被用到，用以和其他情况做区分。</li>
</ul>
<p>:question: <code>slow_enter</code> 中 <code>else if</code> 分支，也即 <code>code 2</code> 处是处理实际上不存在多线程竞争的一种情况，轻量级锁的锁重入的情况，但我实在是想不到哪些情况能进入该分支……只能猜测或许是一些非常规情况（如在某些不恰当的时机调用了 <code>Object#hashCode</code> 方法）。</p>
<p>并发程序的运行情况往往很复杂，会有很多意想不到的情况，想要完全考虑周全是很困难的，另外验证并发程序的正确性也是一件麻烦事。<br>因此从并发编程实践的角度来说，就算诸如上面的 <code>else if</code> 分支处理是多余的，那无非也就多了一些冗余的代码，换来的好处却是显而易见的：</p>
<ul>
<li>首先就是能减少程序员并发编程时的很多心智负担，一来不用去考虑一些边边角角的情况，二来能对并发程序进行划分，为下一阶段的并发程序提供一个隐式的断言。</li>
<li>另外如果此类的分支真的命中，可以提高并发程序的性能或安全性。</li>
</ul>
<h4 id="锁释放失败入口-InterpreterRuntime-monitorexit-分析"><a href="#锁释放失败入口-InterpreterRuntime-monitorexit-分析" class="headerlink" title="锁释放失败入口 InterpreterRuntime::monitorexit 分析"></a>锁释放失败入口 <code>InterpreterRuntime::monitorexit</code> 分析</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CASE</span>(_monitorexit): &#123;</span><br><span class="line">  oop lockee = <span class="built_in">STACK_OBJECT</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">CHECK_NULL</span>(lockee);</span><br><span class="line">  <span class="comment">// derefing&#x27;s lockee ought to provoke implicit null check</span></span><br><span class="line">  <span class="comment">// find our monitor slot</span></span><br><span class="line">  BasicObjectLock* limit = istate-&gt;<span class="built_in">monitor_base</span>();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;<span class="built_in">stack_base</span>();</span><br><span class="line">  <span class="comment">// 从低往高遍历栈的 Lock Record</span></span><br><span class="line">  <span class="keyword">while</span> (most_recent != limit ) &#123;</span><br><span class="line">    <span class="comment">// 如果 Lock Record 关联的是该锁对象</span></span><br><span class="line">    <span class="keyword">if</span> ((most_recent)-&gt;<span class="built_in">obj</span>() == lockee) &#123;</span><br><span class="line">      BasicLock* lock = most_recent-&gt;<span class="built_in">lock</span>();</span><br><span class="line">      markOop header = lock-&gt;<span class="built_in">displaced_header</span>();</span><br><span class="line">      <span class="comment">// 开始锁释放流程</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 首先将 LockRecord 的 obj 指向 NULL</span></span><br><span class="line">      most_recent-&gt;<span class="built_in">set_obj</span>(<span class="literal">NULL</span>);</span><br><span class="line">      <span class="comment">// 如果是偏向模式，仅仅 LockRecord 的 obj 指向 NULL 即完成释放。因此偏向锁的释放不存在失败的情况</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!lockee-&gt;<span class="built_in">mark</span>()-&gt;<span class="built_in">has_bias_pattern</span>()) &#123;</span><br><span class="line">        <span class="comment">// 否则锁不处于偏向模式，要走轻量级锁或重量级锁的释放流程</span></span><br><span class="line">        <span class="comment">// 走到这里 LockRecord 存在三种情况：</span></span><br><span class="line">        <span class="comment">// (1) header 为 NULL，该 LockRecord 对应的加锁情况是：轻量级锁重入</span></span><br><span class="line">        <span class="comment">//     目前锁可能为轻量级锁，也可能是膨胀中，也可能为重量级锁</span></span><br><span class="line">        <span class="comment">// (2) header 为 lockee 的 markword 的无锁状态，该 LockRecord 对应的加锁情况是：轻量级锁初次锁定</span></span><br><span class="line">        <span class="comment">//     目前锁可能为轻量级锁，也可能是膨胀中，也可能为重量级锁</span></span><br><span class="line">        <span class="comment">// (3) header 为 unused 状态，该 LockRecord 对应的加锁情况是：锁膨胀后的所有加锁情况</span></span><br><span class="line">        <span class="comment">//     目前锁只可能为重量级锁</span></span><br><span class="line">        <span class="type">bool</span> call_vm = UseHeavyMonitors;</span><br><span class="line">        <span class="comment">// header 为 NULL 对应轻量级锁重入的加锁情况，可以直接结束，无论目前锁状态是什么。</span></span><br><span class="line">        <span class="keyword">if</span> (header != <span class="literal">NULL</span> || call_vm) &#123;</span><br><span class="line">          <span class="comment">// 如果 header 不为 NULL，做 CAS，只有一种加锁情况可以 CAS 成功：轻量级锁初次锁定 且 锁目前仍然为轻量级锁的情况</span></span><br><span class="line">          <span class="keyword">if</span> (call_vm || Atomic::<span class="built_in">cmpxchg_ptr</span>(header, lockee-&gt;<span class="built_in">mark_addr</span>(), lock) != lock) &#123;</span><br><span class="line">            <span class="comment">// 其他加锁情况均会 CAS 失败：</span></span><br><span class="line">            <span class="comment">// (1) 轻量级锁初次锁定，但 锁目前处于膨胀中或已经是重量级锁状态。</span></span><br><span class="line">            <span class="comment">// (2) 锁膨胀后的所有加锁情况，也即使用重量级锁 Monitor 加锁</span></span><br><span class="line">            <span class="comment">// 失败后，先将 LockRecord 的 obj 还原，重新指向 lockee 锁对象，然后调用 monitorexit 方法</span></span><br><span class="line">            most_recent-&gt;<span class="built_in">set_obj</span>(lockee);</span><br><span class="line">            <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">monitorexit</span>(THREAD, most_recent), handle_exception);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">UPDATE_PC_AND_TOS_AND_CONTINUE</span>(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理下一条Lock Record</span></span><br><span class="line">    most_recent++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Need to throw illegal monitor state exception</span></span><br><span class="line">  <span class="built_in">CALL_VM</span>(InterpreterRuntime::<span class="built_in">throw_illegal_monitor_state_exception</span>(THREAD), handle_exception);</span><br><span class="line">  <span class="built_in">ShouldNotReachHere</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是锁释放流程。可以看到，进入锁释放失败入口 <code>InterpreterRuntime::monitorexit</code> 只可能存在两种情况：</p>
<ul>
<li>线程 A 初次锁定轻量级锁<ul>
<li>线程 B 来获取轻量级锁导致锁膨胀，在锁膨胀中途，线程 A 想要以轻量级锁方式释放锁，失败</li>
<li>线程 B 来获取轻量级锁导致锁膨胀，锁膨胀为重量级锁后，线程 A 想要以轻量级锁方式释放锁，失败</li>
</ul>
</li>
<li>线程 A 在锁膨胀后的所有加锁，也即使用重量级锁 Monitor 加锁，想要以轻量级锁方式释放锁，失败</li>
</ul>
<p><code>InterpreterRuntime::monitorexit</code> 的代码很简短，主要是调用了 <code>ObjectSynchronizer::slow_exit</code>，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">IRT_ENTRY_NO_ASYNC</span>(<span class="type">void</span>, InterpreterRuntime::<span class="built_in">monitorexit</span>(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前释放锁的线程和 LockRecord 打包封装为一个 h_obj 对象</span></span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 调用 slow_exit</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">slow_exit</span>(<span class="built_in">h_obj</span>(), elem-&gt;<span class="built_in">lock</span>(), thread);</span><br><span class="line">  <span class="comment">// Free entry. This must be done here, since a pending exception might be installed on</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// slow_exit 结束后，解锁完毕，将 LockRecord 的 obj ref 指针重新设置为 NULL，完成 LockRecord 的释放</span></span><br><span class="line">  elem-&gt;<span class="built_in">set_obj</span>(<span class="literal">NULL</span>);</span><br><span class="line">  ...</span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>
<p><code>ObjectSynchronizer::slow_exit</code> 调用的是 <code>ObjectSynchronizer::fast_exit</code>，<code>fast_exit</code> 最后锁膨胀得到 <code>Monitor</code> 后再调用其 <code>exit</code> 方法解锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::slow_exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">fast_exit</span> (object, lock, THREAD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectSynchronizer::fast_exit</span><span class="params">(oop object, BasicLock* lock, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  markOop dhw = lock-&gt;<span class="built_in">displaced_header</span>();</span><br><span class="line">  markOop mark ;</span><br><span class="line">  <span class="keyword">if</span> (dhw == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="comment">// 奇怪的分支 code 1: 轻量级锁重入，什么也不做，直接退出即可</span></span><br><span class="line">   	 <span class="comment">// ...</span></span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mark = object-&gt;<span class="built_in">mark</span>() ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 奇怪的分支 code 2: 轻量级锁初次锁定 且 锁目前仍然为轻量级锁的情况，CAS 解锁</span></span><br><span class="line">  <span class="keyword">if</span> (mark == (markOop) lock) &#123;</span><br><span class="line">     <span class="built_in">assert</span> (dhw-&gt;<span class="built_in">is_neutral</span>(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="keyword">if</span> ((markOop) Atomic::<span class="built_in">cmpxchg_ptr</span> (dhw, object-&gt;<span class="built_in">mark_addr</span>(), mark) == mark) &#123;</span><br><span class="line">        <span class="built_in">TEVENT</span> (fast_exit: release stacklock) ;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 前面所有处理都是再次检查，是否不需要锁膨胀就可以解锁，如果是就处理，避免走到下面</span></span><br><span class="line">  <span class="comment">// 走到这里说明是重量级锁或者解锁时发生了竞争，膨胀后调用重量级锁 Monitor 的 exit 方法。</span></span><br><span class="line">  ObjectSynchronizer::<span class="built_in">inflate</span>(THREAD, object)-&gt;<span class="built_in">exit</span> (<span class="literal">true</span>, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><h4 id="为什么需要一个膨胀中的状态"><a href="#为什么需要一个膨胀中的状态" class="headerlink" title="为什么需要一个膨胀中的状态"></a>为什么需要一个膨胀中的状态</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Why do we CAS a 0 into the mark-word instead of just CASing the</span></span><br><span class="line"><span class="comment">// mark-word from the stack-locked value directly to the new inflated state?</span></span><br><span class="line"><span class="comment">// Consider what happens when a thread unlocks a stack-locked object.</span></span><br><span class="line"><span class="comment">// It attempts to use CAS to swing the displaced header value from the</span></span><br><span class="line"><span class="comment">// on-stack basiclock back into the object header.  Recall also that the</span></span><br><span class="line"><span class="comment">// header value (hashcode, etc) can reside in (a) the object header, or</span></span><br><span class="line"><span class="comment">// (b) a displaced header associated with the stack-lock, or (c) a displaced</span></span><br><span class="line"><span class="comment">// header in an objectMonitor.  The inflate() routine must copy the header</span></span><br><span class="line"><span class="comment">// value from the basiclock on the owner&#x27;s stack to the objectMonitor, all</span></span><br><span class="line"><span class="comment">// the while preserving the hashCode stability invariants.  If the owner</span></span><br><span class="line"><span class="comment">// decides to release the lock while the value is 0, the unlock will fail</span></span><br><span class="line"><span class="comment">// and control will eventually pass from slow_exit() to inflate.  The owner</span></span><br><span class="line"><span class="comment">// will then spin, waiting for the 0 value to disappear.   Put another way,</span></span><br><span class="line"><span class="comment">// the 0 causes the owner to stall if the owner happens to try to</span></span><br><span class="line"><span class="comment">// drop the lock (restoring the header from the basiclock to the object)</span></span><br><span class="line"><span class="comment">// while inflation is in-progress.  This protocol avoids races that might</span></span><br><span class="line"><span class="comment">// would otherwise permit hashCode values to change or &quot;flicker&quot; for an object.</span></span><br><span class="line"><span class="comment">// Critically, while object-&gt;mark is 0 mark-&gt;displaced_mark_helper() is stable.</span></span><br><span class="line"><span class="comment">// 0 serves as a &quot;BUSY&quot; inflate-in-progress indicator.</span></span><br></pre></td></tr></table></figure>
<p>其实注释已经说得非常清楚了，我结合自己的理解翻译一下：</p>
<p>为什么我们要将膨胀中状态（即 <code>0</code>） CAS 到锁对象的 <code>markword</code> 中，而不是直接将 <code>markword</code> 从指向 <code>LockRecord</code> 的地址值 CAS 到指向重量级锁 <code>Monitor</code> 的地址呢？</p>
<p>考虑线程做轻量级锁的初次解锁时的情况，它会试图使用 CAS 将 <code>LockRecord</code> 的 <code>displaced mark word</code> 中存放的 <code>lockee</code> 的 <code>markword</code> 的无锁状态，重新挪回到 <code>lockee</code> 中去，从而 <code>lockee</code> 恢复为无锁状态。</p>
<p>回忆一下，锁对象原始 <code>markword</code> 头部信息可能存放在哪些位置：<br>(a) 锁对象头部，此时处于无锁状态<br>(b) 栈空间中与锁对象关联的第一个 <code>LockRecord</code> 的 <code>displaced mark word</code> 中<br>(c) 重量级锁 <code>Monitor</code> 的 <code>header</code> 中</p>
<p>JDK1.6 以前，<code>synchronized</code> 只有 <code>Monitor</code> 重量级锁，彼时如果对象已经加锁了，想要获取重量级锁对象的原始 <code>markword</code> 头部信息，就需要到 (c) 中去获取。<br>后续引入轻量级锁后，如果对象已经加轻量级锁了，想要获取轻量级锁对象的原始 <code>markword</code> 头部信息，就要到 (b) 中获取；当然如果对象加的是重量级锁，获取重量级锁对象的原始 <code>markword</code> 头部信息，依然是到 (c) 中去获取。</p>
<p>为了保证轻量级锁升级到重量级锁后，能够正确地获取原始 <code>markword</code> 头部信息，锁膨胀时，就必须将原来存放在 (b) 中下原始 <code>markword</code> 头部信息，复制一份放到 (c) 中去，并保证这个膨胀升级过程中原始信息如 <code>hashCode</code> 的不变性。</p>
<p>如果不设置一个膨胀中的状态，就会无法保证膨胀升级过程中的原始信息不变性，考虑如下情况：</p>
<ol>
<li>线程 A 调用了 <code>hashCode</code></li>
<li>线程 A 进行轻量级锁的初次锁定</li>
<li>线程 B 尝试获取轻量级锁，开始进行锁膨胀，锁膨胀至少包含下面的操作：<br>3.1 将锁对象的 <code>markword</code> 从指向 <code>LockRecord</code> 改为指向 <code>Monitor</code><br>3.2 将 <code>LockRecord</code> 中的原始头部信息，复制到 <code>Monitor</code> 的 <code>header</code> 中去</li>
<li>由于整个锁膨胀不是原子的，假设线程 B 执行完 (3.1) 后，线程 A 再次调用了 <code>hashCode</code><br>此时，锁对象的 <code>markword</code> 表示对象已经是重量级锁状态，因此线程 A 回到 <code>Monitor</code> 中去获取 <code>hashCode</code>，但线程 B 还未执行 (3.2)，因此返回必然是错误值。</li>
<li>等到线程 B 执行完 (3.2) 以后，线程 A 再次调用 <code>hashCode</code> 就可以拿到正确结果了。</li>
</ol>
<p>注释将这种 <code>hashCode</code> 短暂不一致的情况称为 <code>hashCode</code> 值的闪烁现象。即使调转 (3.1) 和 (3.2) 的顺序，闪烁现象一样存在！</p>
<p>注释提到的破坏不变形的情况更加糟糕！线程 B 执行了 (3.1) 但还没来得及执行 (3.2) 时，线程 A 释放了锁，此时就是重量级锁的释放流程，有可能将 <code>Monitor</code> 中错误的 <code>header</code> 放回到锁对象的 <code>markword</code> 中。这样释放锁后，对象的对象头部不仅 <code>markword</code> 信息可能是错的，还可能没有正确地被设为无锁状态，甚至这种错误信息还是长期存在的。</p>
<p>为了应对这种情况，锁膨胀加入了一个膨胀中的（0）状态：<br>3.1 将对象的 <code>markword</code> 从指向 <code>LockRecord</code> 改为膨胀中的 <code>0</code> 状态<br>3.2 将 <code>LockRecord</code> 中的原始头部信息，复制到 <code>Monitor</code> 的 <code>header</code> 中去<br>3.3 将对象的 <code>markword</code> 从膨胀中的 <code>0</code> 状态改为指向 <code>Monitor</code><br>线程 B 执行了 (3.1) 但还没来得及执行 (3.2) 时，线程 A 释放了锁，此时线程 A 发现锁处于膨胀（0）状态，就会进入自旋忙等，直到线程 B 执行了 (3.2) 乃至 (3.3) 后，线程 A 才能够真正去做重量级的锁释放。</p>
<p>关键在于：只要锁处于膨胀中（0）状态，那么最终要换回到对象中的原始 <code>markword</code> 头部信息就是稳定的。</p>
<h4 id="Monitor-机制下的-wait-notify-执行过程"><a href="#Monitor-机制下的-wait-notify-执行过程" class="headerlink" title="Monitor 机制下的 wait/notify 执行过程"></a><code>Monitor</code> 机制下的 <code>wait/notify</code> 执行过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    lock.hashCode();  <span class="comment">// 禁用偏向锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程A等待获取lock锁&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A获取了lock锁&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A将要运行lock.wait()方法进行等待&quot;</span>);</span><br><span class="line">            lock.wait();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程A等待结束&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;Thread-A&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程B等待获取lock锁&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;线程B获取了lock锁&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(<span class="string">&quot;线程B将要运行lock.notify()方法进行通知&quot;</span>);</span><br><span class="line">          lock.notify();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;Thread-B&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单分析一下上述代码的执行过程：</p>
<ul>
<li>首先线程 A 获取到 lock 锁，此时是轻量级锁状态，获取到锁后线程 A 开始执行同步代码块内容</li>
<li>线程 B 尝试获取 lock 锁，但锁已经被线程 A 占用，此时线程 B 进行锁膨胀操作，膨胀后发现锁依然被线程 A 占用，封装线程 B 为 <code>ObjectWaiter</code> 插入到 <code>Monitor.cxq</code> 队列的队首，并 <code>park</code> 进入阻塞状态。</li>
<li>线程 A 执行到 <code>lock.wait()</code> 时，先将线程 A 封装为 <code>ObjectWaiter</code> 并添加到 <code>Monitor.waitSet</code> 中，然后进行锁释放操作，首先将 <code>Monitor.owner</code> 置为 <code>NULL</code>，然后找到 <code>Monitor.cxq</code> 中正在阻塞等待的线程 B 的 <code>ObjectWaiter</code> 从而可以唤醒线程 B。</li>
<li>线程 B 被唤醒后获得锁，执行同步代码块内容</li>
<li>线程 B 执行到 <code>lock.notify()</code> 时，会将 <code>Monitor.waitSet</code> 中存放的线程 A 的 <code>ObjectWaiter</code> 移动到 <code>Monitor.entryList</code> 中，而不会立刻唤醒</li>
<li>线程 B 继续执行同步块中的剩余代码，执行完毕后释放锁，首先将 <code>Monitor.owner</code> 置为 <code>NULL</code>，然后找到 <code>Monitor.entryList</code> 中阻塞等待的线程 A 的 <code>ObjectWaiter</code> 从而可以唤醒线程 A</li>
<li>线程 A 被唤醒后获得锁，执行剩余的同步代码块内容，执行完毕后释放 lock 锁</li>
</ul>
<h4 id="搁浅现象"><a href="#搁浅现象" class="headerlink" title="搁浅现象"></a>搁浅现象</h4><blockquote>
<p>当竞争发生时，选取一个线程作为 <code>_Responsible</code>，<code>_Responsible</code> 线程调用的是有时间限制的 <code>park</code> 方法，其目的是防止出现搁浅现象。</p>
</blockquote>
<p>:question: 实在想不明白搁浅现象是个什么现象，下面贴一段 <code>ObjectMonitor::exit</code> 方法定义前的一段注释，后续有能力再回头研究…</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1-0 exit</span></span><br><span class="line"><span class="comment">// ~~~~~~~~</span></span><br><span class="line"><span class="comment">// ::exit() uses a canonical 1-1 idiom with a MEMBAR although some of</span></span><br><span class="line"><span class="comment">// the fast-path operators have been optimized so the common ::exit()</span></span><br><span class="line"><span class="comment">// operation is 1-0.  See i486.ad fast_unlock(), for instance.</span></span><br><span class="line"><span class="comment">// The code emitted by fast_unlock() elides the usual MEMBAR.  This</span></span><br><span class="line"><span class="comment">// greatly improves latency -- MEMBAR and CAS having considerable local</span></span><br><span class="line"><span class="comment">// latency on modern processors -- but at the cost of &quot;stranding&quot;.  Absent the</span></span><br><span class="line"><span class="comment">// MEMBAR, a thread in fast_unlock() can race a thread in the slow</span></span><br><span class="line"><span class="comment">// ::enter() path, resulting in the entering thread being stranding</span></span><br><span class="line"><span class="comment">// and a progress-liveness failure.   Stranding is extremely rare.</span></span><br><span class="line"><span class="comment">// We use timers (timed park operations) &amp; periodic polling to detect</span></span><br><span class="line"><span class="comment">// and recover from stranding.  Potentially stranded threads periodically</span></span><br><span class="line"><span class="comment">// wake up and poll the lock.  See the usage of the _Responsible variable.</span></span><br></pre></td></tr></table></figure>
<h4 id="重量级锁的释放-ObjectMonitor-exit-分析"><a href="#重量级锁的释放-ObjectMonitor-exit-分析" class="headerlink" title="重量级锁的释放 ObjectMonitor::exit 分析"></a>重量级锁的释放 <code>ObjectMonitor::exit</code> 分析</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> ATTR <span class="title">ObjectMonitor::exit</span><span class="params">(<span class="type">bool</span> not_suspended, TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="built_in">assert</span> (THREAD == _owner, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="comment">// Knob_ExitPolicy 默认为 0</span></span><br><span class="line">    <span class="keyword">if</span> (Knob_ExitPolicy == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// code 1：当前线程先释放锁，这时如果有其他线程进入同步块则能获得锁</span></span><br><span class="line">      OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">      OrderAccess::<span class="built_in">storeload</span>() ;                         <span class="comment">// See if we need to wake a successor</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// code 2：如果当前已经没有等待的线程或已经有假定继承人，则无需做后续唤醒操作，直接退出</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">TEVENT</span> (Inflated exit - simple egress) ;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">TEVENT</span> (Inflated exit - complex egress) ;</span><br><span class="line">      <span class="comment">// code 3：后续唤醒操作必须独占锁执行，因此 cas 设置 _owner 为当前线程</span></span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">TEVENT</span> (Exit - Reacquired) ;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// code 4：根据 QMode 不同（QMode 默认为 0），执行不同的唤醒策略，来选择 _cxq 或 _EntryList 中合适的线程，调用 ExitEpilog 方法进行唤醒</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>exit</code> 方法中 <code>code 1</code> 及以前的代码必然是单线程执行的，不存在并发情况，因为锁是独占的，只有获取锁的那个线程才能执行到 <code>exit</code> 方法来做锁释放逻辑。</p>
<p>但这并不意味着，整个 <code>exit</code> 方法都是不存在并发的，其实 <code>code 1</code> 之后的代码都是要考虑并发情况的，其中：</p>
<ul>
<li><code>code 1</code> 释放锁之后的代码一直到 <code>code 3</code> 这几行代码是多个线程并发执行的情况，<code>code 3</code> 中的 <code>cas</code> 操作也说明了这一点。</li>
<li><code>code 4</code> 的代码不存在多线程并发执行的情况，其中主要考虑的是 <code>_cxq</code> 的并发安全。因为唤醒可能会涉及到对 <code>_cxq</code> 队列的一些操作，但同时可能有大量的其他线程获取锁并阻塞，这些线程也需要操作 <code>_cxq</code>：向 <code>_cxq</code> 中插入自己的 <code>ObjectWaiter</code>。</li>
</ul>
<p><code>code 1</code> 处当前线程一旦将 <code>owner</code> 设置为 <code>NULL</code> 后，锁其实就已经释放掉了，此时如果有新的线程来访问同步代码块，就立刻可以 <code>cas</code> 获得锁。</p>
<ul>
<li>假设最初是线程 A 来持有锁，它在 <code>code 1</code> 处将 <code>owner</code> 为 <code>NULL</code> 从而释放了锁。</li>
<li>然后线程 B 来访问同步代码块，发现 <code>owner</code> 为 <code>NULL</code>，因此获得锁，获得锁以后，它很快执行完了同步代码块的内容，它也在 <code>code 1</code> 处将 <code>owner</code> 为 <code>NULL</code> 从而释放了锁。</li>
<li>此时线程 A 和线程 B 可能同时处在 <code>code 2</code> 的位置想要继续往下执行，这就出现了并发</li>
</ul>
<p><code>code 2</code> 处：</p>
<ul>
<li>如果已经没有等待的线程，那么并发的线程 A 和线程 B 都直接退出，无需进行后面 <code>code 4</code> 的唤醒操作，这个很好理解。</li>
<li>如果还存在等待的线程，那么就需要做后面 <code>code 4</code> 的唤醒操作。假设是线程 A 完成了后续的唤醒并选定了假定继承人，从而 <code>_succ</code> 可能就非 <code>NULL</code>，这时候线程 B 并发执行 <code>code 2</code>，发现 <code>_succ</code> 非 <code>NULL</code> 就可以直接退出。</li>
</ul>
<p><code>code 3</code> 处：</p>
<ul>
<li>如果当前已经有其他线程，比如新线程 C 获取到了锁，那么线程 A 和线程 B 将在 <code>code 3</code> 处 CAS 失败直接退出，无需后面的唤醒操作。这个很好理解，到时后线程 C 释放的时候，它来负责唤醒。</li>
<li>如果当前没有其他线程获取到锁，此时为了避免唤醒多个线程，让线程 A 和线程 B 去 <code>cas</code> 竞争，从而保证只有一个线程可以进入后续的 <code>code 4</code> 去做唤醒。</li>
</ul>
<p>为什么要保证只有一个线程进入 <code>code 4</code> 呢？来看一下 <code>ObjectMonitor::ExitEpilog</code> 的代码就懂了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ObjectMonitor::ExitEpilog</span> <span class="params">(Thread * Self, ObjectWaiter * Wakee)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span> (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将从 _cxq 或 _EntryList 中选中的线程设为假定继承人 _succ</span></span><br><span class="line">  _succ = Knob_SuccEnabled ? Wakee-&gt;_thread : <span class="literal">NULL</span> ;</span><br><span class="line">  ParkEvent * Trigger = Wakee-&gt;_event ;</span><br><span class="line">  Wakee  = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放锁，注意此时假定继承人还处在 park 状态，因此这时如果有其他线程进入同步块则能获得锁</span></span><br><span class="line">  OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">  OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SafepointSynchronize::<span class="built_in">do_call_back</span>()) &#123;</span><br><span class="line">    <span class="built_in">TEVENT</span> (unpark before SAFEPOINT) ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">DTRACE_MONITOR_PROBE</span>(contended__exit, <span class="keyword">this</span>, <span class="built_in">object</span>(), Self);</span><br><span class="line">  <span class="comment">// 调用 unpark，线程真正被唤醒，继续执行 ObjectMonitor::EnterI 方法</span></span><br><span class="line">  Trigger-&gt;<span class="built_in">unpark</span>() ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多个线程来唤醒，就有多个线程去执行 <code>ExitEpilog</code> 方法，从而存在线程安全问题。<br>假设线程 A 和线程 B 都可以进入 <code>code 4</code> 执行 <code>ExitEpilog</code> 方法</p>
<ul>
<li>线程 A 执行 <code>ExitEpilog</code> 方法将 <code>owner</code> 设置为 <code>NULL</code> 释放锁，此时新线程 D 来访问同步代码块获得了锁，执行同步代码块</li>
<li>线程 D 还未执行完同步代码块。线程 B 也执行 <code>ExitEpilog</code> 方法将 <code>owner</code> 设置为 <code>NULL</code> 释放锁，明明是线程 D 持有锁，可却让线程 B 去释放了，此时如果新线程 E 来访问同步代码块，也能获得锁，从而线程 D 和线程 E 都在执行同步代码块</li>
</ul>
<p>除此 <code>ExitEpilog</code> 方法之外，唤醒还包括了一系列对 <code>_cxq</code> 和 <code>_EntryList</code> 的操作，这些操作在并发执行时也可能存在线程安全问题。</p>
<h4 id="轻量级锁重入后，锁膨胀并再次发生多次重量级锁重入后，是什么情况"><a href="#轻量级锁重入后，锁膨胀并再次发生多次重量级锁重入后，是什么情况" class="headerlink" title="轻量级锁重入后，锁膨胀并再次发生多次重量级锁重入后，是什么情况"></a>轻量级锁重入后，锁膨胀并再次发生多次重量级锁重入后，是什么情况</h4><p>假设线程 A 初次锁定轻量级锁，然后又发生了一次轻量级锁重入，而后线程 B 来获取轻量级锁导致锁膨胀，膨胀后的情况如下：</p>
<p><img src="/img/itheima-juc/轻量级锁重入后锁膨胀.svg" alt=""></p>
<p>膨胀后，线程 A 再次获取锁，发生一次重量级锁重入，情况如下：</p>
<p><img src="/img/itheima-juc/轻量级锁重入后锁膨胀并又发生一次重量级锁重入.svg" alt=""></p>
<p>重量级锁重入的这次加锁对应的 <code>LockRecord 3</code>，其 <code>displaced mark word</code> 被标记为 <code>unused</code>。</p>
<p>另外 <code>Monitor</code> 的变化是：</p>
<ul>
<li><code>_recursions</code> 加 1</li>
<li><code>owner</code> 从指向 <code>LockRecord 1</code> 变为指向线程 A</li>
<li><code>OwnerIsThread</code> 从 0 置为 1</li>
</ul>
<p>后续如果继续有重量级锁重入，只需要递增 <code>_recursions</code> 即可，不再需要修改 <code>owner</code> 和 <code>OwnerIsThread</code>。</p>
<h4 id="何时重量级锁对象恢复到无锁状态"><a href="#何时重量级锁对象恢复到无锁状态" class="headerlink" title="何时重量级锁对象恢复到无锁状态"></a>何时重量级锁对象恢复到无锁状态</h4><p>你可能注意到了，重量级锁对象的释放，似乎只是将 <code>Owner</code> 置为 <code>null</code> 就结束了。那何时重量级锁对象会恢复到无锁状态呢？下面来探讨这个问题</p>
<p>重量级锁的释放大致可以分为两种场景：</p>
<ul>
<li><code>Monitor</code> 中存在正在等待的其他线程，此时释放逻辑是先将 <code>Owner</code> 置为 <code>null</code>，然后一般是从 <code>cxq</code> 或 <code>EntryList</code> 中取出一个线程并唤醒作为候选，候选竞争成功后才作为新的 <code>Owner</code>。注意是单一唤醒而不是群体唤醒，具体策略取决于 <code>QMode</code>，一般是取出 <code>EntryList</code> 的队首线程。</li>
<li><code>Monitor</code> 中已经不存在正在等待的其他线程，此时释放逻辑是 <code>Owner</code> 置为 <code>null</code> 就直接结束重量级锁的释放逻辑。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// ObjectMonitor::exit </span></span><br><span class="line">   <span class="comment">// 释放锁，将 owner 置为 NULL</span></span><br><span class="line">   OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>);  </span><br><span class="line">   OrderAccess::<span class="built_in">storeload</span>();    </span><br><span class="line">   <span class="comment">// 如果 EntryList 和 cxq 中均没有等待的线程，直接 return 退出                     </span></span><br><span class="line">   <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">TEVENT</span> (Inflated exit - simple egress);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   ```   </span><br><span class="line"></span><br><span class="line">也就是说，重量级锁的释放方法 `ObjectMonitor::exit` 中，并没有包含对象 `markword` 恢复到无锁状态的逻辑。</span><br><span class="line"></span><br><span class="line">其实对象恢复到无锁状态的逻辑，是在锁的撤销膨胀逻辑中实现的，撤销膨胀操作发生在 `safepoint`。</span><br><span class="line"></span><br><span class="line">`safepoint` 是一个所有 Java 线程都暂停执行的点，系统可以执行一些必须在所有线程都暂停时才能做的任务（比如某些 `GC` 任务，之前提到的偏向锁撤销等），`SafepointSynchronize::do_cleanup_tasks` 描述了在 `safepoint` 期间执行的一系列任务，其中就包括 `ObjectSynchronizer::deflate_idle_monitors`。</span><br><span class="line"></span><br><span class="line">`ObjectSynchronizer::deflate_idle_monitors` 被调用时，它会遍历所有存在的`Monitor`，查找那些不再关联任何对象的空闲 `monitor`，并分别调用 `ObjectSynchronizer::deflate_monitor` 完成具体的撤销膨胀操作。</span><br><span class="line"></span><br><span class="line">当与锁对象关联的 `Monitor` 被 `deflate` 时，系统会将存放在 `Monitor` 的 `header` 中锁对象的原始的 `markword` 头部信息取出，重新设置到锁对象的对象头的 `markword` 上，从而锁对象恢复到无锁状态。相关源码如下：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// ObjectSynchronizer::deflate_monitor</span></span><br><span class="line"><span class="comment">// mid 就是 Monitor 对象，取出保存在 header 中的原始信息如 hashcode，重新设置到锁对象的对象头的 markword 中，从而锁对象恢复到无锁状态</span></span><br><span class="line">obj-&gt;<span class="built_in">release_set_mark</span>(mid-&gt;<span class="built_in">header</span>());</span><br><span class="line"><span class="comment">// 清除 Monitor 对象数据，为后续归还到一个全局空闲列表做好准备</span></span><br><span class="line">mid-&gt;<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">RQTN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/itheima-juc/synchronized%20%E5%8E%9F%E7%90%86/">http://example.com/itheima-juc/synchronized%20%E5%8E%9F%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">RQTN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/itheima-juc/">itheima-juc</a><a class="post-meta__tags" href="/tags/synchronized/">synchronized</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--重量级锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">好文收录 - 死磕Synchronized底层实现--重量级锁</div></div></a></div><div class="next-post pull-right"><a href="/itheima-mysql/MVCC%20-%20undo%20log%20%E7%89%88%E6%9C%AC%E9%93%BE%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99/" title="MVCC - undo log 版本链数据访问规则"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MVCC - undo log 版本链数据访问规则</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E5%81%8F%E5%90%91%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--偏向锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-26</div><div class="title">好文收录 - 死磕Synchronized底层实现--偏向锁</div></div></a></div><div><a href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E6%A6%82%E8%AE%BA/" title="好文收录 - 死磕Synchronized底层实现--概论"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-25</div><div class="title">好文收录 - 死磕Synchronized底层实现--概论</div></div></a></div><div><a href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--轻量级锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-27</div><div class="title">好文收录 - 死磕Synchronized底层实现--轻量级锁</div></div></a></div><div><a href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--重量级锁"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="title">好文收录 - 死磕Synchronized底层实现--重量级锁</div></div></a></div><div><a href="/itheima-juc/%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/" title="变量的线程安全分析 —— 纠错与笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">变量的线程安全分析 —— 纠错与笔记</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RQTN</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RQTN"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RQTN" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">synchronized 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%A7%80%E5%8D%9A%E6%96%87%E6%8E%A8%E8%8D%90"><span class="toc-number">1.1.</span> <span class="toc-text">优秀博文推荐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-number">1.2.</span> <span class="toc-text">预备知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#klass-lockee-LockRecord-%E4%B8%89%E8%80%85%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">klass, lockee, LockRecord 三者的联系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-number">1.3.</span> <span class="toc-text">偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E4%BB%A5%E5%8F%8A%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">偏向锁以及轻量级锁的加锁流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E9%94%81%E9%87%8D%E5%85%A5"><span class="toc-number">1.3.2.</span> <span class="toc-text">偏向锁的锁重入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E5%81%8F%E5%90%91%E6%92%A4%E9%94%80-%E9%94%81%E5%8D%87%E7%BA%A7%E5%85%A5%E5%8F%A3-InterpreterRuntime-monitorenter-%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90%E6%95%B4%E4%B8%AA%E5%81%8F%E5%90%91%E6%92%A4%E9%94%80%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.3.</span> <span class="toc-text">从偏向撤销&#x2F;锁升级入口 InterpreterRuntime::monitorenter 开始分析整个偏向撤销流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%81%8F%E5%90%91%E6%92%A4%E9%94%80%E4%B8%80%E8%88%AC%E6%98%AF%E9%9C%80%E8%A6%81%E5%9C%A8-safepoint-%E6%9C%9F%E9%97%B4%E6%9D%A5%E5%AE%8C%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-number">1.3.4.</span> <span class="toc-text">为什么偏向撤销一般是需要在 safepoint 期间来完成的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91"><span class="toc-number">1.3.5.</span> <span class="toc-text">批量重偏向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="toc-number">1.3.6.</span> <span class="toc-text">批量撤销</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.4.</span> <span class="toc-text">轻量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E9%94%81%E9%87%8D%E5%85%A5"><span class="toc-number">1.4.1.</span> <span class="toc-text">轻量级锁的锁重入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Hotspot-%E9%80%89%E6%8B%A9%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%A0%88%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%A4%9A%E4%B8%AA-LockRecord-%E6%9D%A5%E8%A1%A8%E7%A4%BA%E9%94%81%E9%87%8D%E5%85%A5%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">为什么 Hotspot 选择在线程栈中添加多个 LockRecord 来表示锁重入？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ObjectSynchronizer-slow-enter-%E8%A1%A5%E5%85%85%E5%88%86%E6%9E%90"><span class="toc-number">1.4.3.</span> <span class="toc-text">ObjectSynchronizer::slow_enter 补充分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E9%87%8A%E6%94%BE%E5%A4%B1%E8%B4%A5%E5%85%A5%E5%8F%A3-InterpreterRuntime-monitorexit-%E5%88%86%E6%9E%90"><span class="toc-number">1.4.4.</span> <span class="toc-text">锁释放失败入口 InterpreterRuntime::monitorexit 分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.5.</span> <span class="toc-text">重量级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AA%E8%86%A8%E8%83%80%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">为什么需要一个膨胀中的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Monitor-%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84-wait-notify-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">Monitor 机制下的 wait&#x2F;notify 执行过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%81%E6%B5%85%E7%8E%B0%E8%B1%A1"><span class="toc-number">1.5.3.</span> <span class="toc-text">搁浅现象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE-ObjectMonitor-exit-%E5%88%86%E6%9E%90"><span class="toc-number">1.5.4.</span> <span class="toc-text">重量级锁的释放 ObjectMonitor::exit 分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E9%87%8D%E5%85%A5%E5%90%8E%EF%BC%8C%E9%94%81%E8%86%A8%E8%83%80%E5%B9%B6%E5%86%8D%E6%AC%A1%E5%8F%91%E7%94%9F%E5%A4%9A%E6%AC%A1%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E9%87%8D%E5%85%A5%E5%90%8E%EF%BC%8C%E6%98%AF%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5"><span class="toc-number">1.5.5.</span> <span class="toc-text">轻量级锁重入后，锁膨胀并再次发生多次重量级锁重入后，是什么情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E5%AF%B9%E8%B1%A1%E6%81%A2%E5%A4%8D%E5%88%B0%E6%97%A0%E9%94%81%E7%8A%B6%E6%80%81"><span class="toc-number">1.5.6.</span> <span class="toc-text">何时重量级锁对象恢复到无锁状态</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-mysql/MVCC%20-%20undo%20log%20%E7%89%88%E6%9C%AC%E9%93%BE%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99/" title="MVCC - undo log 版本链数据访问规则">MVCC - undo log 版本链数据访问规则</a><time datetime="2023-06-27T14:19:24.000Z" title="发表于 2023-06-27 22:19:24">2023-06-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/synchronized%20%E5%8E%9F%E7%90%86/" title="synchronized 原理">synchronized 原理</a><time datetime="2023-05-04T09:46:08.000Z" title="发表于 2023-05-04 17:46:08">2023-05-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--重量级锁">好文收录 - 死磕Synchronized底层实现--重量级锁</a><time datetime="2023-04-27T17:00:08.000Z" title="发表于 2023-04-28 01:00:08">2023-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--轻量级锁">好文收录 - 死磕Synchronized底层实现--轻量级锁</a><time datetime="2023-04-26T17:00:08.000Z" title="发表于 2023-04-27 01:00:08">2023-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E5%81%8F%E5%90%91%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--偏向锁">好文收录 - 死磕Synchronized底层实现--偏向锁</a><time datetime="2023-04-25T17:00:08.000Z" title="发表于 2023-04-26 01:00:08">2023-04-26</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By RQTN</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://unpkg.com/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>