<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>使用爬山法、模拟退火和遗传算法求解八皇后问题 | RQTN</title><meta name="author" content="RQTN"><meta name="copyright" content="RQTN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="使用爬山法、模拟退火和遗传算法求解八皇后问题 实验使用 C++ 语言，并在 Windows 的 Visual Studio 2017 下能够正常运行。 参考书籍：《人工智能：一种现代的方法（第三版）》  1. 准备阶段1.1 Board 类 Board 类数据成员  bool board[8][8]：表示一个 8$\times$8 棋盘的具体情况。某位值为 true 时（即 1），表示该位上为皇后">
<meta property="og:type" content="article">
<meta property="og:title" content="使用爬山法、模拟退火和遗传算法求解八皇后问题">
<meta property="og:url" content="http://example.com/ai/eight-queens/eight-queens/index.html">
<meta property="og:site_name" content="RQTN">
<meta property="og:description" content="使用爬山法、模拟退火和遗传算法求解八皇后问题 实验使用 C++ 语言，并在 Windows 的 Visual Studio 2017 下能够正常运行。 参考书籍：《人工智能：一种现代的方法（第三版）》  1. 准备阶段1.1 Board 类 Board 类数据成员  bool board[8][8]：表示一个 8$\times$8 棋盘的具体情况。某位值为 true 时（即 1），表示该位上为皇后">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2019-08-16T13:04:11.000Z">
<meta property="article:modified_time" content="2024-04-01T00:30:09.618Z">
<meta property="article:author" content="RQTN">
<meta property="article:tag" content="八皇后问题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/ai/eight-queens/eight-queens/index.html"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: RQTN","link":"链接: ","source":"来源: RQTN","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '使用爬山法、模拟退火和遗传算法求解八皇后问题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-01 08:30:09'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index_img_cut.png')"><nav id="nav"><span id="blog-info"><a href="/" title="RQTN"><span class="site-name">RQTN</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">使用爬山法、模拟退火和遗传算法求解八皇后问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2019-08-16T13:04:11.000Z" title="发表于 2019-08-16 21:04:11">2019-08-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/">AI</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="使用爬山法、模拟退火和遗传算法求解八皇后问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="使用爬山法、模拟退火和遗传算法求解八皇后问题"><a href="#使用爬山法、模拟退火和遗传算法求解八皇后问题" class="headerlink" title="使用爬山法、模拟退火和遗传算法求解八皇后问题"></a>使用爬山法、模拟退火和遗传算法求解八皇后问题</h1><blockquote>
<p>实验使用 <code>C++</code> 语言，并在 <code>Windows</code> 的 <code>Visual Studio 2017</code> 下能够正常运行。</p>
<p>参考书籍：《人工智能：一种现代的方法（第三版）》</p>
</blockquote>
<h2 id="1-准备阶段"><a href="#1-准备阶段" class="headerlink" title="1. 准备阶段"></a>1. 准备阶段</h2><h3 id="1-1-Board-类"><a href="#1-1-Board-类" class="headerlink" title="1.1 Board 类"></a>1.1 <code>Board</code> 类</h3><ul>
<li><p><code>Board</code> 类数据成员</p>
<ul>
<li><p><code>bool board[8][8]</code>：表示一个 8$\times$8 棋盘的具体情况。某位值为 <code>true</code> 时（即 1），表示该位上为皇后，否则为 <code>false</code>（即 0），表示该位上没有放置任何东西。</p>
</li>
<li><p><code>int state[8]</code>：表示当前棋盘的状态。使用一个 8 位数串来表示八皇后问题的一个特定的状态。比如 <code>83742516</code> 就表示了这样的一个状态（注意加粗部分）：</p>
<ul>
<li>第 1 列第 <strong>8</strong> 行位置有一个皇后</li>
<li>第 2 列第 <strong>3</strong> 行位置有一个皇后</li>
<li>第 3 列第 <strong>7</strong> 行位置有一个皇后</li>
<li>…</li>
<li>第 8 列第 <strong>6</strong> 行位置有一个皇后</li>
</ul>
<p><img src="/img/ai/eight-queens/2.jpg" alt=""></p>
</li>
<li><p><code>int h_value_board[8][8]</code>：一个辅助数据成员，表示一个 8$\times$8 棋盘上的所有下一步状态的评估值 —— 相互攻击的皇后的对数。其对应于书本上的下图：</p>
<p><img src="/img/ai/eight-queens/1.jpg" alt=""></p>
<p>方格中显示的数字表示将这一列中的皇后移到该方格而得到的后继状态的评估值。</p>
</li>
</ul>
</li>
<li><p><code>Board</code> 类函数成员</p>
<ul>
<li><code>void initial()</code>：将棋盘 <code>board</code> 初始化，初始化后棋盘上不会放置任何皇后。</li>
<li><code>void fill_in_board()</code>：内部先调用了一次 <code>initial()</code>，然后根据 <code>state</code> 数据成员往棋盘 <code>board</code> 放入 8 个皇后。</li>
<li><code>void random_initial_state()</code>：随机产生一个初始状态，赋值给 <code>state</code> 数据成员。</li>
<li><code>void display(int mode)</code>：打印当前棋盘的信息，<code>mode</code> 参数用于选择打印方式。</li>
<li><code>void display_h_value_on_board()</code>：打印当前棋盘的 <code>h_value_board</code> 数据成员。</li>
<li><code>void set_state(string state_)</code>：手动设置初始状态 <code>state</code> 而不是随机产生。</li>
<li><code>string get_state()</code>：获得 <code>state</code> 数据成员</li>
<li><code>bool check(int mode)</code>： 检查当前棋盘上八皇后的放置是否已经满足要求，也即八皇后问题是否成功求解。<code>mode</code> 参数用于选择检查方式。</li>
<li><code>int h_of_attack_pair()</code>：启发式评估函数 —— 相互攻击的皇后的数量。</li>
<li><code>int h_of_not_attack_pair()</code>：启发式评估函数 —— 不相互攻击的皇后的数量。</li>
<li><code>int count_attack(int x, int y)</code>：给定皇后的位置 <code>x</code> 和 <code>y</code>，该函数计算在棋盘 <code>(x, y)</code> 位置上的皇后与多少个其他位置上的皇后形成相互攻击 。</li>
</ul>
</li>
</ul>
<h3 id="1-2-其他全局变量"><a href="#1-2-其他全局变量" class="headerlink" title="1.2 其他全局变量"></a>1.2 其他全局变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> SHC_success_total_steps = <span class="number">0</span>;    <span class="comment">// 最陡上升爬山法成功总步数，除以成功次数以求得成功平均步数</span></span><br><span class="line"><span class="type">int</span> SHC_failed_total_steps = <span class="number">0</span>;        <span class="comment">// 最陡上升爬山法失败总步数，除以失败次数以求得失败平均步数</span></span><br><span class="line"><span class="type">int</span> FCHC_success_total_steps = <span class="number">0</span>;    <span class="comment">// 首选爬山法成功总步数，除以成功次数以求得成功平均步数</span></span><br><span class="line"><span class="type">int</span> FCHC_failed_total_steps = <span class="number">0</span>;    <span class="comment">// 首选爬山法失败总步数，除以失败次数以求得失败平均步数</span></span><br><span class="line"><span class="type">int</span> RRSHC_success_total_steps = <span class="number">0</span>;    <span class="comment">// 随机重启爬山法成功总步数，除以成功次数以求得成功平均步数</span></span><br><span class="line"><span class="type">int</span> RRSHC_failed_total_steps = <span class="number">0</span>;    <span class="comment">// 随机重启爬山法失败总步数，除以失败次数以求得失败平均步数</span></span><br><span class="line"><span class="type">int</span> SA_success_total_steps = <span class="number">0</span>;        <span class="comment">// 模拟退火成功总步数，除以成功次数以求得成功平均步数</span></span><br><span class="line"><span class="type">int</span> SA_failed_total_steps = <span class="number">0</span>;        <span class="comment">// 模拟退火失败总步数，除以失败次数以求得失败平均步数</span></span><br><span class="line"><span class="type">int</span> generation = <span class="number">0</span>;                    <span class="comment">// 遗传算法成功所需总代数，除以成功次数以求得成功平均所需代数</span></span><br><span class="line">Board b_tool;                        <span class="comment">// Board 对象，仅作为工具来使用其中的一些函数成员</span></span><br></pre></td></tr></table></figure>
<h2 id="2-爬山法"><a href="#2-爬山法" class="headerlink" title="2. 爬山法"></a>2. 爬山法</h2><blockquote>
<p>具体实现了最陡上升爬山法，首选爬山法和随机重启爬山法。</p>
</blockquote>
<h3 id="2-1-最陡上升爬山法"><a href="#2-1-最陡上升爬山法" class="headerlink" title="2.1 最陡上升爬山法"></a>2.1 最陡上升爬山法</h3><h4 id="2-1-1-代码实现"><a href="#2-1-1-代码实现" class="headerlink" title="2.1.1 代码实现"></a>2.1.1 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Steepest_Hill_Climbing</span><span class="params">(Board* board)</span> </span>&#123;        <span class="comment">// 给定一个待求解的棋盘（八皇后已放置）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    string old_state = board-&gt;<span class="built_in">get_state</span>();        <span class="comment">// 旧状态</span></span><br><span class="line">    string new_state = old_state;                <span class="comment">// 新状态，旧状态的后继</span></span><br><span class="line">    string best_state = old_state;                <span class="comment">// 最好的新状态</span></span><br><span class="line">    <span class="type">int</span> min_h = board-&gt;<span class="built_in">h_of_attack_pair</span>();        <span class="comment">// 最好的状态评估值</span></span><br><span class="line">    <span class="type">int</span> new_h;                                    <span class="comment">// 新状态的评估值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ++steps;                                <span class="comment">// 循环步数，对应着探索后继的步数</span></span><br><span class="line">        <span class="type">bool</span> local_max_flag = <span class="literal">true</span>;                <span class="comment">// 局部最大值 flag</span></span><br><span class="line">        <span class="comment">// 对于棋盘第 i 列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 对第 i 列中的那个皇后，尝试其他的可能性（移动到 i 列中的其他行）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (old_state[i] != j + <span class="string">&#x27;0&#x27;</span>) &#123;    <span class="comment">// 若第 j 行不是 i 列中有皇后的那一行</span></span><br><span class="line">                    </span><br><span class="line">                    new_state = old_state;        </span><br><span class="line">                    new_state[i] = j + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 尝试把当前 i 列的皇后移到第 j 行</span></span><br><span class="line">                    board-&gt;<span class="built_in">set_state</span>(new_state);</span><br><span class="line">                    board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">                    new_h = board-&gt;<span class="built_in">h_of_attack_pair</span>();    <span class="comment">// 对这次移动尝试使用评估函数进行评估</span></span><br><span class="line"></span><br><span class="line">                    board-&gt;h_value_board[j][i] = new_h; <span class="comment">// 保存这次移动尝试的评估值</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (new_h &lt; min_h) &#123;    <span class="comment">// 一旦有移动尝试的评估值更好</span></span><br><span class="line">                        min_h = new_h;        <span class="comment">// 爬山，更新最好的评估值</span></span><br><span class="line">                        best_state = new_state;        <span class="comment">// 更新最佳后继状态</span></span><br><span class="line">                        local_max_flag = <span class="literal">false</span>;        <span class="comment">// 爬山成功，将局部最大值 flag 置假</span></span><br><span class="line">                        <span class="keyword">if</span> (min_h == <span class="number">0</span>) &#123;            <span class="comment">// 找到全局最大值</span></span><br><span class="line">                            SHC_success_total_steps += steps; <span class="comment">// 记录成功求解的循环步数</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 返回 true 表示求解成功</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若第 j 行是 i 列中有皇后的那一行</span></span><br><span class="line">                <span class="keyword">else</span> board-&gt;h_value_board[j][i] = <span class="number">0</span>; <span class="comment">// 赋值 0 以标志当前皇后位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board-&gt;<span class="built_in">set_state</span>(best_state);    <span class="comment">// 将最佳后继状态置为当前状态</span></span><br><span class="line">        board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">        old_state = best_state;</span><br><span class="line">        <span class="comment">// board-&gt;display();</span></span><br><span class="line">        <span class="comment">// board-&gt;display_h_value_on_board();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (local_max_flag) &#123;            <span class="comment">// 如果所有的移动尝试都没有更好的评估值</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;Attain local max: break the hill-climbing&quot; &lt;&lt; endl;</span></span><br><span class="line">            SHC_failed_total_steps += steps;    <span class="comment">// 失败，记录失败的循环步数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                <span class="comment">// 返回 false 表示求解失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-测试"><a href="#2-1-2-测试" class="headerlink" title="2.1.2 测试"></a>2.1.2 测试</h4><ul>
<li><p><code>void SHC_test1()</code>：最陡上升爬山法测试函数 —— 进行 3 次最陡上升爬山法求解测试，分别是</p>
<ul>
<li>初始状态 <code>16471352</code> (几乎成功的初始状态，<code>06471352</code> 即为八皇后的一个解)</li>
<li>初始状态 <code>45634565</code> (书本上的初始状态) </li>
<li>随机初始状态</li>
</ul>
<p><img src="/img/ai/eight-queens/3.jpg" alt=""></p>
<p>观察到，对于</p>
<ul>
<li>几乎成功的初始状态，最陡上升爬山法成功找到了解。</li>
<li>书本上的初始状态，最陡上升爬山法未能找到解，且和书上一样最后卡在了 <code>h = 1</code> 的状态。</li>
<li>随机初始状态，最陡上升爬山法未能找到解。</li>
</ul>
<p>对于这三次测试，容易发现，<strong><code>h</code> 值（也即相互攻击的皇后的对数）都下降了，也即最陡上升爬山法虽然不一定得到全局最大值，但确实改善了八皇后问题的状态，使其到达了一个较好的局部最大值。</strong></p>
</li>
<li><p><code>void SHC_test2()</code>：最陡上升爬山法测试函数 —— 进行 1000 次最陡上升爬山法求解测试，<strong>统计最陡上升爬山法的成功几率，成功平均步数和失败平均步数</strong></p>
<p><img src="/img/ai/eight-queens/4.jpg" alt=""></p>
</li>
</ul>
<h3 id="2-2-首选爬山法"><a href="#2-2-首选爬山法" class="headerlink" title="2.2 首选爬山法"></a>2.2 首选爬山法</h3><h4 id="2-2-1-代码实现"><a href="#2-2-1-代码实现" class="headerlink" title="2.2.1 代码实现"></a>2.2.1 代码实现</h4><blockquote>
<p>和最陡上升爬山法只有非常细微的差别。最陡上升爬山法中，我们需要对当前状态的所有后继状态进行尝试，然后<strong>选出其中评估值最优的后继状态作为我们的后继状态</strong>，这也即<strong>最陡上升</strong>；而在首选爬山法中，我们<strong>一旦找到一个比当前状态评估值更优的后继状态，我们就将其作为后继状态</strong>，这也即<strong>首选</strong>。不难理解，首选爬山法的效率会比最陡上升爬山法低。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">First_Choice_Hill_Climbing</span><span class="params">(Board* board)</span> </span>&#123;    <span class="comment">// 给定一个待求解的棋盘（八皇后已放置）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    string old_state = board-&gt;<span class="built_in">get_state</span>();        <span class="comment">// 旧状态</span></span><br><span class="line">    string new_state = old_state;                <span class="comment">// 新状态，旧状态的后继</span></span><br><span class="line">    string best_state = old_state;                <span class="comment">// 最好的新状态</span></span><br><span class="line">    <span class="type">int</span> min_h = board-&gt;<span class="built_in">h_of_attack_pair</span>();        <span class="comment">// 最好的状态评估值</span></span><br><span class="line">    <span class="type">int</span> new_h;                                    <span class="comment">// 新状态的评估值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;                                    </span><br><span class="line">        ++steps;                                <span class="comment">// 循环步数，对应着探索后继的步数</span></span><br><span class="line">        <span class="type">bool</span> find_flag = <span class="literal">false</span>;                    <span class="comment">// 首选 flag</span></span><br><span class="line">        <span class="comment">// 对于棋盘第 i 列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 对第 i 列中的那个皇后，尝试其他的可能性（移动到 i 列中的其他行）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (old_state[i] != j + <span class="string">&#x27;0&#x27;</span>) &#123;    <span class="comment">// 若第 j 行不是 i 列中有皇后的那一行</span></span><br><span class="line"></span><br><span class="line">                    new_state = old_state;</span><br><span class="line">                    new_state[i] = j + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 尝试把当前 i 列的皇后移到第 j 行</span></span><br><span class="line">                    board-&gt;<span class="built_in">set_state</span>(new_state);</span><br><span class="line">                    board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">                    new_h = board-&gt;<span class="built_in">h_of_attack_pair</span>();     <span class="comment">// 对这次移动尝试使用评估函数进行评估</span></span><br><span class="line"></span><br><span class="line">                    board-&gt;h_value_board[j][i] = new_h; <span class="comment">// 保存这次移动尝试的评估值</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (new_h &lt; min_h) &#123;    <span class="comment">// 一旦有移动尝试的评估值更好</span></span><br><span class="line">                        min_h = new_h;        <span class="comment">// 爬山，更新最好的评估值</span></span><br><span class="line">                        best_state = new_state;    <span class="comment">// 更新最佳后继状态</span></span><br><span class="line">                        find_flag = <span class="literal">true</span>;    <span class="comment">// 将首选 flag 置真，首选完毕准备跳出 for 循环</span></span><br><span class="line">                        <span class="keyword">if</span> (min_h == <span class="number">0</span>) &#123;    <span class="comment">// 找到全局最大值</span></span><br><span class="line">                            FCHC_success_total_steps += steps;    <span class="comment">// 记录成功求解的循环步数</span></span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 返回 ture 表示成功求解</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若第 j 行是 i 列中有皇后的那一行</span></span><br><span class="line">                <span class="keyword">else</span> board-&gt;h_value_board[j][i] = <span class="number">0</span>; <span class="comment">// 赋值 0 以标志当前皇后位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find_flag) <span class="keyword">break</span>;    <span class="comment">// 找到首选，跳出 for 循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board-&gt;<span class="built_in">set_state</span>(best_state);    <span class="comment">// 将最佳后继状态（首选后继状态）置为当前状态</span></span><br><span class="line">        board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">        <span class="comment">// board-&gt;display();</span></span><br><span class="line">        <span class="comment">// board-&gt;display_h_value_on_board();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!find_flag) &#123;                <span class="comment">// 如果所有的移动尝试都没有更好的评估值</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;Attain local max: break the hill-climbing&quot; &lt;&lt; endl;</span></span><br><span class="line">            FCHC_failed_total_steps += steps;    <span class="comment">// 失败，记录失败的循环步数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;                <span class="comment">// 返回 false 表示求解失败</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        old_state = best_state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-测试"><a href="#2-2-2-测试" class="headerlink" title="2.2.2 测试"></a>2.2.2 测试</h4><ul>
<li><p><code>void FCHC_test1()</code>：首选爬山法测试函数 —— 进行 3 次首选爬山法求解测试，分别是</p>
<ul>
<li>初始状态 <code>16471352</code> (几乎成功的初始状态，<code>06471352</code> 即为八皇后的一个解)</li>
<li>初始状态 <code>45634565</code> (书本上的初始状态) </li>
<li>随机初始状态</li>
</ul>
<p><img src="/img/ai/eight-queens/5.jpg" alt=""></p>
<p>观察到，对于</p>
<ul>
<li>几乎成功的初始状态，首选爬山法成功找到了解。</li>
<li>书本上的初始状态，首选爬山法未能找到解，和最陡上升爬山法不一样，首选爬山法最后卡在了 <code>h = 2</code> 的状态。</li>
<li>随机初始状态，首选爬山法未能找到解。</li>
</ul>
<p>对于这三次测试，容易发现，<strong><code>h</code> 值（也即相互攻击的皇后的对数）都下降了，也即首选爬山法虽然不一定得到全局最大值，但确实改善了八皇后问题的状态，使其到达了一个较好的局部最大值。</strong></p>
</li>
<li><p><code>void SHC_test2()</code>：首选爬山法测试函数 —— 进行 1000 次首选爬山法求解测试，<strong>统计首选爬山法的成功几率，成功平均步数和失败平均步数</strong></p>
<p><img src="/img/ai/eight-queens/6.jpg" alt=""></p>
<p>正如我们所预期的那样，<strong>首选爬山法和最陡上升爬山法的成功几率相近，但相较于最陡上升爬山法，首选爬山法的成功平均步数和失败平均步数都明显更大一些，这也即意味着首选爬山法的效率更低。</strong></p>
</li>
</ul>
<h3 id="2-3-随机重启爬山法"><a href="#2-3-随机重启爬山法" class="headerlink" title="2.3 随机重启爬山法"></a>2.3 随机重启爬山法</h3><blockquote>
<p>我们选择<strong>最陡上升</strong>作为随机重启爬山法的爬山策略，当最陡上升爬山法遇到局部最大值而失败，我们将随机生成一个新的初始状态再次使用最陡上升爬山法重启爬山。为简单探求随机重启爬山法的完备性，我们设置重启次数上限为 1000 次。</p>
</blockquote>
<h4 id="2-3-1-代码实现"><a href="#2-3-1-代码实现" class="headerlink" title="2.3.1 代码实现"></a>2.3.1 代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Random_Restart_Steepest_Hill_Climbing</span><span class="params">(Board* board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机重启上限为 1000 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Steepest_Hill_Climbing</span>(board)) &#123;    <span class="comment">// 最陡上升爬山若失败</span></span><br><span class="line">            board-&gt;<span class="built_in">random_initial_state</span>();        <span class="comment">// 重新随机生成初始状态</span></span><br><span class="line">            board-&gt;<span class="built_in">fill_in_board</span>();                <span class="comment">// 按新的初始状态放置 8 皇后</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;                                    <span class="comment">// 最陡上升爬山若成功</span></span><br><span class="line">            RRSHC_success_total_steps += (SHC_failed_total_steps + SHC_success_total_steps);                    <span class="comment">// 记录随机重启爬山法的成功步数</span></span><br><span class="line">            SHC_success_total_steps = <span class="number">0</span>;</span><br><span class="line">            SHC_failed_total_steps = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;                        <span class="comment">// 返回 true 表示求解成功</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机重启 1000 次仍然未找到解</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录随机重启爬山法的失败步数</span></span><br><span class="line">    RRSHC_failed_total_steps += (SHC_failed_total_steps + SHC_success_total_steps);</span><br><span class="line">    SHC_success_total_steps = <span class="number">0</span>;</span><br><span class="line">    SHC_failed_total_steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;                                <span class="comment">// 返回 false 表示求解失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-测试"><a href="#2-3-2-测试" class="headerlink" title="2.3.2 测试"></a>2.3.2 测试</h4><ul>
<li><p><code>void RRSHC_test1()</code>：随机重启爬山法测试函数 —— 进行 3 次随机重启爬山法求解测试，分别是</p>
<ul>
<li>初始状态 <code>16471352</code> (几乎成功的初始状态，<code>06471352</code> 即为八皇后的一个解)</li>
<li>初始状态 <code>45634565</code> (书本上的初始状态) </li>
<li>随机初始状态</li>
</ul>
<p><img src="/img/ai/eight-queens/7.jpg" alt=""></p>
<p>观察到，<strong>对于三种初始状态，随机重启爬山法都成功找到了解</strong>。</p>
</li>
<li><p><code>void RRSHC_test2()</code>：随机重启爬山法测试函数 —— 进行 1000 次随机重启爬山法求解测试，<strong>统计随机重启爬山法的成功几率，成功平均步数和失败平均步数</strong></p>
<p><img src="/img/ai/eight-queens/8.jpg" alt=""></p>
<p>可以看到<strong>随机重启爬山法总是成功的</strong>。正如书上所说的那样：<strong>随机重启爬山法完备的概率接近于 1 ，因为只要随机重启的次数上限足够大，那么最终我们能够随机重启生成一个目标状态（成功状态）作为初始状态。对于八皇后问题而言，随机重启次数上限为 1000 次已经基本能够保证找到解。</strong></p>
</li>
</ul>
<ul>
<li><strong>设置不同的随机重启次数上限，调用 <code>RRSHC_test2()</code> 以探究对于八皇后问题而言较好的随机重启上限</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">随机重启次数上限</th>
<th style="text-align:center">成功求解概率</th>
<th style="text-align:center">成功平均步数</th>
<th style="text-align:center">失败平均步数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">0.559</td>
<td style="text-align:center">10.5331</td>
<td style="text-align:center">20.4807</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0.806</td>
<td style="text-align:center">17.4169</td>
<td style="text-align:center">40.6856</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">0.955</td>
<td style="text-align:center">23.5403</td>
<td style="text-align:center">82.4667</td>
</tr>
<tr>
<td style="text-align:center">50</td>
<td style="text-align:center">1</td>
<td style="text-align:center">28.813</td>
<td style="text-align:center">never failed</td>
</tr>
</tbody>
</table>
</div>
<p>  可以看到，<strong>对于八皇后问题而言，50次随机重启，算法已经是几乎完备的。</strong></p>
<h2 id="3-模拟退火"><a href="#3-模拟退火" class="headerlink" title="3. 模拟退火"></a>3. 模拟退火</h2><blockquote>
<p>相比于爬山法，模拟退火最大的特点是：<strong>允许下山</strong>。<strong>如果温度下降得足够慢，也即退火足够慢，那么模拟退火算法找到全局最优解的概率逼近于 1。</strong></p>
</blockquote>
<p>我们先简要介绍并分析一下模拟退火算法。</p>
<p>对于八皇后问题而言，<strong>模拟退火算法随机抽取 1 个当前状态的后继状态</strong>。既然是随机抽取，那么就必然存在随机抽取的新的后继状态会比当前状态要差的情况，在下面的代码中，我们<strong>使用不相互攻击的皇后的数量 <code>h_of_not_attack_pair()</code> 来计算状态的评估值</strong>，评估值被用作评判状态好坏的依据。</p>
<p>如果我们的新状态比当前状态要好，也即评估值更优，那么模拟退火算法会欣然接受这个新的状态。</p>
<p>如果我们的新状态比当前状态要差，也即评估值更差，那么<strong>模拟退火算法不会像爬山法一样丢弃这个新的状态，而是允许下山：模拟退火算法以某个小于 1 的概率接受这个新的状态</strong>。</p>
<p><strong>这个概率的设计，同样是模拟退火算法的关键</strong>。</p>
<p>下面分析代码中使用的八皇后问题的概率公式：</p>
<script type="math/tex; mode=display">
\Delta E=next.Value-current.Value
\\
P=e^{\frac{\Delta E}{T}}</script><p>因为我们使用不相互攻击的皇后的数量来计算状态的评估值，所以如果后继 <code>next</code> 的状态相对更差，那么其不相互攻击的皇后数量是更少的，这也即 $\Delta E &lt; 0$  。又因为 $T$ 总是个正数，所以 $\frac{\Delta E}{T} &lt; 0$ ，结合 $y=e^x$ 图像可知，$P=e^\frac{\Delta E}{T}&lt;1$，这说明代码中的模拟退火算法确实是以小于 1 的概率接受这个新的状态。</p>
<p> $P=e^\frac{\Delta E}{T}$ 中有两个变量，分别是 $\Delta E$ 和 $T$。</p>
<ul>
<li><p><strong>我们从一个短的时间段看待 $P$，则 $T$ 在短时间内几乎没有什么变化（设计上也是这样要求的 —— 退火越慢算法越完备），那么此时影响 $P$ 的主要变量是 $\Delta E$。 此时，如果后继状态相比于当前状态越差，那么 $\Delta E$ 就会越负（本身就已经小于 0），$P$ 就越小，较差的后继状态就越不可能被接受。</strong></p>
</li>
<li><p><strong>我们从一个长的时间段看待 $P$，则 $\Delta E$ 在长时间段上的变化是类似的，因为后继状态是随机挑选的，且 $\Delta E$ 变化再大，也是有上限的，对于当前的八皇后问题而言，$\Delta E$ 的变化不可能绝对值大于 28。换句话说，在长时间段上，影响 $P$ 的主要变量是 $T$。</strong></p>
<p>一开始， $T$ 的值为 5（代码实现里初始温度设为 5），但经过较长的时间之后，$T$ 的值会变为 0.01，甚至更小。假设 $\Delta E$ 不变（更直观地，假设$\Delta E=-3$），那么 $P_b=e^\frac{\Delta E}{5}=0.5488$，$P_e=e^\frac{\Delta E}{0.001}=e^\frac{500\Delta E}{5}=(P_b)^{500}=5.148e-131$。可见，对于同样差了 3 个等级的后继状态（$\Delta E$），最开始模拟退火算法有大约一半的概率接受，而当 $T$ 的值变的较小时，较差的后继状态几乎不可能被接受。</p>
<p>而这一点是模拟退火算法概率设计的关键：<strong>一开始，模拟退火算法接受较差后继状态的概率较大，越往后，模拟退火算法就越不可能接受一个较差的后继状态</strong>。</p>
<p>书上也有个形象的例子：想象在高低不平的平面上有个乒乓球想掉落到最深的裂缝中去，那么模拟退火的方法就是一开始使劲摇晃（先高温加热）然后慢慢降低摇晃的强度（后逐渐降温）。</p>
</li>
</ul>
<h3 id="3-1-代码实现"><a href="#3-1-代码实现" class="headerlink" title="3.1 代码实现"></a>3.1 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 退火函数</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">schedule</span><span class="params">(<span class="type">float</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.99</span> * T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIMULATED-ANNEALING</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Simulated_Annealing</span><span class="params">(Board* board, <span class="type">float</span>(*p)(<span class="type">float</span>))</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> T = <span class="number">5</span>;        <span class="comment">// 把初始温度设置为 5</span></span><br><span class="line">    string old_state = board-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">    string new_state = old_state;</span><br><span class="line">    <span class="type">int</span> old_value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> new_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T &gt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">        ++steps;</span><br><span class="line">        old_value = board-&gt;<span class="built_in">h_of_not_attack_pair</span>();    <span class="comment">// 使用不相互攻击的皇后的对数作为评价函数</span></span><br><span class="line">        <span class="keyword">if</span> (board-&gt;<span class="built_in">check</span>(<span class="number">1</span>)) &#123;                        <span class="comment">// 如果成功找到解</span></span><br><span class="line">            SA_success_total_steps += steps;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T = (*p)(T);                                <span class="comment">// 降温</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机选择一个新的邻接状态</span></span><br><span class="line">        <span class="comment">// 随机抽取一个列 y</span></span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">rand</span>() % <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 随机抽取该列中的 free 的行 x（也即没有皇后的行）</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            x = <span class="built_in">rand</span>() % <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">if</span> (x != old_state[y] - <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        new_state = old_state;</span><br><span class="line">        new_state[y] = x + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        board-&gt;<span class="built_in">set_state</span>(new_state);</span><br><span class="line">        board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">        new_value = board-&gt;<span class="built_in">h_of_not_attack_pair</span>();    <span class="comment">// 随机新状态的评估值</span></span><br><span class="line">        <span class="type">int</span> deltaE = (new_value - old_value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (deltaE &gt; <span class="number">0</span>) &#123;                            <span class="comment">// 如果新的评估值更优</span></span><br><span class="line">            old_state = new_state;                    <span class="comment">// 更新为新的状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; deltaE &lt;&lt; &quot;: &quot; &lt;&lt; T &lt;&lt; &quot;:&quot; &lt;&lt; deltaE / T &lt;&lt; &quot; : &quot; &lt;&lt; exp(deltaE / T) &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// 如果新的评估值差于旧的评估值，则有小概率采纳新的较差的评估值对应的新状态，允许下山</span></span><br><span class="line">            <span class="keyword">if</span> (((<span class="type">float</span>)(<span class="built_in">rand</span>() % <span class="number">1000</span>) / <span class="number">1000</span>) &lt; <span class="built_in">exp</span>(deltaE / T)) &#123;</span><br><span class="line">                old_state = new_state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">// 较差的新状态被否决，时间越长，较差的新状态越容易被否决</span></span><br><span class="line">                board-&gt;<span class="built_in">set_state</span>(old_state);</span><br><span class="line">                board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SA_failed_total_steps += steps;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-测试"><a href="#3-2-测试" class="headerlink" title="3.2 测试"></a>3.2 测试</h3><ul>
<li><p><code>void SA_test1()</code>：模拟退火测试函数 —— 进行 3 次模拟退火求解测试，分别是</p>
<ul>
<li>初始状态 <code>16471352</code> (几乎成功的初始状态，<code>06471352</code> 即为八皇后的一个解)</li>
<li>初始状态 <code>45634565</code> (书本上的初始状态) </li>
<li>随机初始状态</li>
</ul>
<p><img src="/img/ai/eight-queens/9.jpg" alt=""></p>
<p>观察到，<strong>对于三种初始状态，模拟退火都成功找到了解</strong>。注意，<strong>在爬山法里解的 <code>h</code> 值为 0，但在模拟退火里解的 <code>h</code> 值为 28，这是因为前者使用相互攻击的皇后的对数作为启发式评估函数，后者使用不相互攻击的皇后的对数作为启发式评估函数。</strong></p>
</li>
<li><p><code>void SA_test2()</code>：模拟退火测试函数 —— 进行 1000 次模拟退火求解测试，<strong>统计模拟退火的成功几率，成功平均步数和失败平均步数</strong></p>
<p><img src="/img/ai/eight-queens/10.jpg" alt=""></p>
<p>虽然在 <code>SA_test1()</code> 中三次都成功都找到了解，但实际上对于初始温度 $T=5$，退火函数 $T = 0.99 T$ 的模拟退火，<strong>我们并不总能成功找到解</strong>，成功的概率是 0.781。而<strong>相比爬山法，容易发现模拟退火的成功平均步数和失败平均步数都发生了巨大的递增。这反映了爬山法确实效率很高，这是优点也是缺点。</strong></p>
</li>
</ul>
<ul>
<li><strong>设置不同的退火速率，调用 <code>SA_test2()</code> 以探究退火速率对于八皇后问题求解的完备性的影响</strong>：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">退火速率</th>
<th style="text-align:center">成功求解概率</th>
<th style="text-align:center">成功平均步数</th>
<th style="text-align:center">失败平均步数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T=0.99T</td>
<td style="text-align:center">0.781</td>
<td style="text-align:center">593.36</td>
<td style="text-align:center">1311.96</td>
</tr>
<tr>
<td style="text-align:center">T=0.999T</td>
<td style="text-align:center">0.998</td>
<td style="text-align:center">2578.48</td>
<td style="text-align:center">13116</td>
</tr>
<tr>
<td style="text-align:center">T=0.9999T</td>
<td style="text-align:center">1</td>
<td style="text-align:center">13465.4</td>
<td style="text-align:center">never failed</td>
</tr>
</tbody>
</table>
</div>
<p>  <strong>退火越缓慢，模拟退火成功求解八皇后问题的概率就越高，但随着成功求解概率的提高，成功平均步数和失败平均步数也明显提高。</strong></p>
<h2 id="4-遗传算法"><a href="#4-遗传算法" class="headerlink" title="4. 遗传算法"></a>4. 遗传算法</h2><blockquote>
<p>遗传算法是随机束搜索的一个变形，其最关键的思想在于模拟自然选择，有性繁殖以及模式理论。</p>
</blockquote>
<p>遗传算法实际上用书本上一幅图基本上就能概括：</p>
<p><img src="/img/ai/eight-queens/11.jpg" alt=""></p>
<p><strong>像束搜索一样，最开始我们具有若干个随机生成的初始状态，这些初始状态被称为种群</strong>，也即图中 a 的初始种群。</p>
<p><strong>类比自然选择，遗传算法中，我们确保种群中较好的状态有较大概率参与下一代的繁殖，而较差的状态能够繁殖自己后代的概率较小，我们使用适应度函数来评价种群中的状态</strong>，而在这里我们使用不相互攻击的皇后的对数 <code>h_of_not_attack_pair()</code> 作为适应度函数，这对应着图中的 b 和 c 过程。</p>
<p><strong>类比有性繁殖，我们将要配对的个体，在字符串中随机选择一个杂交点，配对的个体所产生的后代其杂交点前后的状态信息（基因）分别来自于两个参与配对的个体。</strong></p>
<p><strong>这里杂交的可行性来自于模式的思想的支持，如果状态信息（基因）的位置在初始的时候就允许随机转换，那么杂交就没有优势了，因为直观上说，杂交有助于将独立发展出来的有利模式结合起来，提高了搜索的粒度</strong>。</p>
<p><strong>对于整个种群，适应较强的个体其状态信息的一部分也是较优的，也即模式是较优的。较优的模式进行组合，那么我们更容易得到一个整体最优的后代。</strong></p>
<p>最后，我们还<strong>模拟了遗传过程中可能发生的变异，这一点同样是遗传算法成功的关键。</strong></p>
<h3 id="4-1-代码实现"><a href="#4-1-代码实现" class="headerlink" title="4.1 代码实现"></a>4.1 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于挑选种群 p 中参与繁殖的个体，适应度函数评价越高的个体越容易被挑选</span></span><br><span class="line"><span class="function">string <span class="title">Random_Selection</span><span class="params">(vector&lt;string&gt; &amp;p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> total_value = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">h</span><span class="params">(p.size())</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rand_array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        b_tool.<span class="built_in">set_state</span>(p[i]);</span><br><span class="line">        b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        h[i] = b_tool.<span class="built_in">h_of_not_attack_pair</span>();</span><br><span class="line">        total_value += h[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; h[i]; ++j) &#123;</span><br><span class="line">            rand_array.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rv = <span class="built_in">rand</span>() % total_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p[rand_array[rv]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 杂交，给定参与配对的父母状态 x 和 y</span></span><br><span class="line"><span class="function">string <span class="title">Reproduce</span><span class="params">(string x, string y)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cut = <span class="built_in">rand</span>() % <span class="number">7</span>;    <span class="comment">// 0 1 2 3 4 5 6</span></span><br><span class="line">    cut++;                    <span class="comment">// 1 2 3 4 5 6 7</span></span><br><span class="line">    <span class="comment">// 以上两步处理确保杂交点不是第一个数字之前和最后一个数字之后，也即后代一定包括了父母双方的信息</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">substr</span>(<span class="number">0</span>, cut) + y.<span class="built_in">substr</span>(cut); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变异，给定的个体状态 s 以 rate 的几率发生变异</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Mutate</span><span class="params">(string &amp;s, <span class="type">float</span> rate)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rand_mutate_pos = <span class="built_in">rand</span>() % <span class="number">64</span>;</span><br><span class="line">    string new_s = s;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> new_h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">float</span>)(<span class="built_in">rand</span>() % <span class="number">1000</span>) / <span class="number">1000</span>) &lt; rate) &#123;</span><br><span class="line">        new_s[rand_mutate_pos / <span class="number">8</span>] = (rand_mutate_pos % <span class="number">8</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        b_tool.<span class="built_in">set_state</span>(new_s);</span><br><span class="line">        b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        new_h = b_tool.<span class="built_in">h_of_not_attack_pair</span>();</span><br><span class="line">        b_tool.<span class="built_in">set_state</span>(s);</span><br><span class="line">        b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        h = b_tool.<span class="built_in">h_of_not_attack_pair</span>();</span><br><span class="line">        <span class="keyword">if</span> (new_h &gt;= h) s = new_s;                        <span class="comment">// 为加快收敛速度，只保留有利变异</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印种群，用于观察种群的演化过程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_p</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> str : p) &#123;</span><br><span class="line">        b_tool.<span class="built_in">set_state</span>(str);</span><br><span class="line">        b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; b_tool.<span class="built_in">h_of_not_attack_pair</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遗传算法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Genetic_Algorithn</span><span class="params">(vector&lt;string&gt; &amp;p, <span class="type">float</span> mutate_rate)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; old_p = p;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">new_p</span><span class="params">(p.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遗传代数设置为 10000 代</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10000</span>; ++n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 挑选参与繁殖的两个个体</span></span><br><span class="line">            string x = <span class="built_in">Random_Selection</span>(old_p);</span><br><span class="line">            string y = <span class="built_in">Random_Selection</span>(old_p);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 产生后代</span></span><br><span class="line">            string child = <span class="built_in">Reproduce</span>(x, y);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 后代变异</span></span><br><span class="line">            <span class="built_in">Mutate</span>(child, mutate_rate);</span><br><span class="line">            </span><br><span class="line">            new_p[i] = child;</span><br><span class="line">            b_tool.<span class="built_in">set_state</span>(child);</span><br><span class="line">            b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">            <span class="keyword">if</span> (b_tool.<span class="built_in">check</span>(<span class="number">1</span>)) &#123;        <span class="comment">// 若成功找到解，输出到 p[0] 上</span></span><br><span class="line">                p[<span class="number">0</span>] = child;</span><br><span class="line">                generation += n;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        old_p = new_p;                    <span class="comment">// 旧一代种群被新一代种群取代</span></span><br><span class="line">        <span class="built_in">print_p</span>(old_p);                    <span class="comment">// 打印观察种群变化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p = old_p;                            <span class="comment">// 失败，但得到较好的种群</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-测试"><a href="#4-2-测试" class="headerlink" title="4.2 测试"></a>4.2 测试</h3><ul>
<li><p><code>void GA_test1(int p_size = 4, float mutate_rate = 0.5)</code>：遗传算法测试函数，默认情况下，设定遗传算法种群大小为 4 (按书本)，变异概率为 0.5。</p>
<p>随机产生的初始种群为下图中红框圈住部分，记为第 0 代。后续为输出为 第 1 代，第 2 代以及第 3 代的种群情况。</p>
<p><img src="/img/ai/eight-queens/12.jpg" alt=""></p>
<p>第 15 代到第 18 代的种群情况：</p>
<p><img src="/img/ai/eight-queens/13.jpg" alt=""></p>
<p><strong>遗传的代数越多，种群中的个体就越相似，这是无法避免的。</strong>所以，此时变异的重要性就凸显出来了。<strong>如果没有变异，那么相似的个体进行杂交，其后代的状态信息（基因）将很可能和父母相同，进化就此停滞。而变异的普遍存在，确保了会有或者更优或者更差的不同后代的产生，而更优的后代往往更容易获得交配权，将其优秀的状态信息扩散到种群中去，使得整个种群发生进化。</strong></p>
<p>最终，遗传算法在第 289 代找到了最完美的后代，其即为八皇后问题的解：</p>
<p><img src="/img/ai/eight-queens/14.jpg" alt=""></p>
</li>
<li><p><code>void GA_test2(int p_size = 4, float mutate_rate = 0.5)</code>：遗传算法测试函数 —— 进行 1000 次遗传算法求解测试，<strong>统计遗传算法的成功几率，成功平均代数，失败平均代数不需要统计（即为设定的 10000 代）</strong></p>
<p><img src="/img/ai/eight-queens/15.jpg" alt=""></p>
<p>遗传算法的成功求解概率为 0.972，成功平均代数为 892.159，由于运行 <code>GA_test2()</code> 时使用默认的种群大小 4，所以容易求得遗传算法的成功平均步数为 4 $\times$ 892.159 = 3568.636，比模拟退火中 $T=0.999T\times$ 的成功平均步长还要更长一点，但 <strong><code>GA_test2()</code> 运行起来明显花费了更长的时间，我猜想这应该是因为遗传算法的失败代价过高</strong>，就以上的数据而言，总的成功步数为 3568.636 $\times$ 972 = 3468714.19，而总是失败步数为 40000 $\times$ 28 = 1120000。 </p>
</li>
<li><p>除了以上的测试，<strong>还可以设置不同的种群大小和变异概率，调用 <code>GA_test2()</code> 以探究不同的种群大小和变异概率对于八皇后问题求解成功概率和成功平均代数的影响。但鉴于跑一次 <code>GA_test2()</code> 时间过长，所以在这里没有具体进行尝试</strong>。</p>
</li>
</ul>
<h3 id="4-3-实现过程中遇到的问题与思考"><a href="#4-3-实现过程中遇到的问题与思考" class="headerlink" title="4.3 实现过程中遇到的问题与思考"></a>4.3 实现过程中遇到的问题与思考</h3><p>主要的问题还是<strong>遗传算法效率过低</strong>。</p>
<p><strong>遗传算法很容易进入种群内所有个体都基本一样的情境，一旦进入这种情境，遗传算法的种群进化进程将立刻大大减缓。</strong></p>
<p><strong>在种群内个体状态信息（基因型）很多样的时候，杂交能够进一步促进基因的多样性，此外还能变异也能产生新的基因型，所以种群内的总是能够涌现出当前种群中没有的新基因型，一旦新的基因型适应能力更强，那么新的基因型将很容易在种群中传播开。</strong></p>
<p><strong>一旦种群内个体状态信息（基因型）大部分都相似的时候，往往杂交所得后代基因型也与父母的基因型没有太大差别，此时种群要产生新的基因型只能依靠变异，而变异又应该是小概率的，这就使得种群的进化几乎停滞了。</strong></p>
<p>如果只是最基本地实现书上所提到的变异函数，那么基本上大小为 4 的种群在 10000 代内，遗传算法也很大可能不可以找到解。</p>
<p>因此，我的代码实现中的 <code>Mutate(string &amp;s, float rate)</code> 函数不得不对书上所提到的变异函数做了很多额外的改动：<strong>设置了较高的变异概率且只保留适应度函数评价大于等于当前状态的变异，这大概借鉴了一点胚胎致死的思想（如果变异不比当前状态好，那么生出来的机会都没有）。这些改动有助于加快种群的进化。</strong></p>
<p>仔细思考，遗传算法很容易进入所有个体都基本一样的情境实际上也和基因过于简单有关。而现实生活中变异发生的概率虽然低，但是因为基因数量很大，所以在父母和后代之间，基因型几乎比如发生了变化，所以在八皇后实验中，设置较高的变异概率也可视为一种对现实环境的更贴切的模拟，而这也确实提高了遗传算法的效率。</p>
<h2 id="5-完整代码"><a href="#5-完整代码" class="headerlink" title="5. 完整代码"></a>5. 完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Use Hill-Climbing, Simulated-Annealing and Genetic-Algorithm to solve 8-Queens problem */</span></span><br><span class="line"><span class="type">int</span> SHC_success_total_steps = <span class="number">0</span>;    <span class="comment">// 最陡上升爬山法成功总步数</span></span><br><span class="line"><span class="type">int</span> SHC_failed_total_steps = <span class="number">0</span>;        <span class="comment">// 最陡上升爬山法失败总步数</span></span><br><span class="line"><span class="type">int</span> FCHC_success_total_steps = <span class="number">0</span>;    <span class="comment">// 首选爬山法成功总步数</span></span><br><span class="line"><span class="type">int</span> FCHC_failed_total_steps = <span class="number">0</span>;    <span class="comment">// 首选爬山法失败总步数</span></span><br><span class="line"><span class="type">int</span> RRSHC_success_total_steps = <span class="number">0</span>;    <span class="comment">// 随机重启爬山法成功总步数</span></span><br><span class="line"><span class="type">int</span> RRSHC_failed_total_steps = <span class="number">0</span>;    <span class="comment">// 随机重启爬山法失败总步数</span></span><br><span class="line"><span class="type">int</span> SA_success_total_steps = <span class="number">0</span>;        <span class="comment">// 模拟退火成功总步数</span></span><br><span class="line"><span class="type">int</span> SA_failed_total_steps = <span class="number">0</span>;        <span class="comment">// 模拟退火失败总步数</span></span><br><span class="line"><span class="type">int</span> generation = <span class="number">0</span>;                    <span class="comment">// 遗传算法成功所需总代数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Board</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fill_in_board</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">initial</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            board[state[i]][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                board[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">random_initial_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            state[i] = <span class="built_in">rand</span>() % <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> mode)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;-------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;State: &quot;</span> &lt;&lt; <span class="built_in">get_state</span>() &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;h: &quot;</span> &lt;&lt; (mode == <span class="number">0</span> ? <span class="built_in">h_of_attack_pair</span>() : <span class="built_in">h_of_not_attack_pair</span>()) &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Find Solution: &quot;</span> &lt;&lt; (<span class="built_in">check</span>(mode) ? <span class="string">&quot;Success!!!&quot;</span> : <span class="string">&quot;Failed...&quot;</span>) &lt;&lt; endl</span><br><span class="line">            &lt;&lt; <span class="string">&quot;Board: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                cout &lt;&lt; board[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;-------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display_h_value_on_board</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;H_Value On Board: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                cout &lt;&lt; h_value_board[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_state</span><span class="params">(string state_)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            state[i] = state_[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">get_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            res += state[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mode == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">h_of_attack_pair</span>() == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">h_of_not_attack_pair</span>() == <span class="number">28</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">h_of_attack_pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            value += <span class="built_in">count_attack</span>(state[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">h_of_not_attack_pair</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            value += (<span class="number">7</span> - <span class="built_in">count_attack</span>(state[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">count_attack</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != y &amp;&amp; board[x][i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x, j = y; i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[--i][--j]) count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x, j = y; i &lt; <span class="number">7</span> &amp;&amp; j &lt; <span class="number">7</span>; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[++i][++j]) count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x, j = y; i &gt; <span class="number">0</span> &amp;&amp; j &lt; <span class="number">7</span>; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[--i][++j]) count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x, j = y; i &lt; <span class="number">7</span> &amp;&amp; j &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[++i][--j]) count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> h_value_board[<span class="number">8</span>][<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> board[<span class="number">8</span>][<span class="number">8</span>];    <span class="comment">// 棋盘</span></span><br><span class="line">    <span class="type">int</span> state[<span class="number">8</span>];        <span class="comment">// 状态的 8 位数串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Board b_tool;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HILL-CLIMBING</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Steepest_Hill_Climbing</span><span class="params">(Board* board)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    string old_state = board-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">    string new_state = old_state;</span><br><span class="line">    string best_state = old_state;</span><br><span class="line">    <span class="type">int</span> min_h = board-&gt;<span class="built_in">h_of_attack_pair</span>();</span><br><span class="line">    <span class="type">int</span> new_h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ++steps;</span><br><span class="line">        <span class="type">bool</span> local_max_flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 对于 i 列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 i 列中的皇后尝试其他的可能性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (old_state[i] != j + <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    new_state = old_state;</span><br><span class="line">                    new_state[i] = j + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    board-&gt;<span class="built_in">set_state</span>(new_state);</span><br><span class="line">                    board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">                    new_h = board-&gt;<span class="built_in">h_of_attack_pair</span>();</span><br><span class="line"></span><br><span class="line">                    board-&gt;h_value_board[j][i] = new_h;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (new_h &lt; min_h) &#123;</span><br><span class="line">                        min_h = new_h;</span><br><span class="line">                        best_state = new_state;</span><br><span class="line">                        local_max_flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">if</span> (min_h == <span class="number">0</span>) &#123;</span><br><span class="line">                            SHC_success_total_steps += steps;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> board-&gt;h_value_board[j][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board-&gt;<span class="built_in">set_state</span>(best_state);</span><br><span class="line">        board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">        <span class="comment">// board-&gt;display();</span></span><br><span class="line">        <span class="comment">// board-&gt;display_h_value_on_board();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (local_max_flag) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;Attain local max: break the hill-climbing&quot; &lt;&lt; endl;</span></span><br><span class="line">            SHC_failed_total_steps += steps;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        old_state = best_state;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">First_Choice_Hill_Climbing</span><span class="params">(Board* board)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    string old_state = board-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">    string new_state = old_state;</span><br><span class="line">    string best_state = old_state;</span><br><span class="line">    <span class="type">int</span> min_h = board-&gt;<span class="built_in">h_of_attack_pair</span>();</span><br><span class="line">    <span class="type">int</span> new_h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        ++steps;</span><br><span class="line">        <span class="type">bool</span> find_flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 对于 i 列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// 将 i 列中的皇后尝试其他的可能性</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (old_state[i] != j + <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    new_state = old_state;</span><br><span class="line">                    new_state[i] = j + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">                    board-&gt;<span class="built_in">set_state</span>(new_state);</span><br><span class="line">                    board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">                    new_h = board-&gt;<span class="built_in">h_of_attack_pair</span>();</span><br><span class="line"></span><br><span class="line">                    board-&gt;h_value_board[j][i] = new_h;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (new_h &lt; min_h) &#123;</span><br><span class="line">                        min_h = new_h;</span><br><span class="line">                        best_state = new_state;</span><br><span class="line">                        find_flag = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (min_h == <span class="number">0</span>) &#123;</span><br><span class="line">                            FCHC_success_total_steps += steps;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> board-&gt;h_value_board[j][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find_flag) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        board-&gt;<span class="built_in">set_state</span>(best_state);</span><br><span class="line">        board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">        <span class="comment">// board-&gt;display();</span></span><br><span class="line">        <span class="comment">// board-&gt;display_h_value_on_board();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!find_flag) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; &quot;Attain local max: break the hill-climbing&quot; &lt;&lt; endl;</span></span><br><span class="line">            FCHC_failed_total_steps += steps;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        old_state = best_state;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Random_Restart_Steepest_Hill_Climbing</span><span class="params">(Board* board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机重启 1000 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Steepest_Hill_Climbing</span>(board)) &#123;</span><br><span class="line">            board-&gt;<span class="built_in">random_initial_state</span>();</span><br><span class="line">            board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            RRSHC_success_total_steps += (SHC_failed_total_steps + SHC_success_total_steps);</span><br><span class="line">            SHC_success_total_steps = <span class="number">0</span>;</span><br><span class="line">            SHC_failed_total_steps = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    RRSHC_failed_total_steps += (SHC_failed_total_steps + SHC_success_total_steps);</span><br><span class="line">    SHC_success_total_steps = <span class="number">0</span>;</span><br><span class="line">    SHC_failed_total_steps = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SHC_test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Board board;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the first cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">initial</span>();</span><br><span class="line">    board.<span class="built_in">set_state</span>(<span class="string">&quot;16471352&quot;</span>);</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Steepest_Hill_Climbing</span>(&amp;board);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the second cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">set_state</span>(<span class="string">&quot;45634565&quot;</span>);</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Steepest_Hill_Climbing</span>(&amp;board);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the third cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">random_initial_state</span>();</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Steepest_Hill_Climbing</span>(&amp;board);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SHC_test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Board board;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        board.<span class="built_in">initial</span>();</span><br><span class="line">        board.<span class="built_in">random_initial_state</span>();</span><br><span class="line">        board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        cout &lt;&lt; board.<span class="built_in">get_state</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Steepest_Hill_Climbing</span>(&amp;board);</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Steepest_Hill_Climbing: &quot;</span> &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Success Rate: &quot;</span> &lt;&lt; <span class="built_in">float</span>(count) / <span class="number">1000</span> &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;/1000]&quot;</span> &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Success average steps: &quot;</span> &lt;&lt; <span class="built_in">float</span>(SHC_success_total_steps) / count &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Failed average steps: &quot;</span> &lt;&lt; <span class="built_in">float</span>(SHC_failed_total_steps) / (<span class="number">1000</span> - count) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FCHC_test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Board board;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the first cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">initial</span>();</span><br><span class="line">    board.<span class="built_in">set_state</span>(<span class="string">&quot;16471352&quot;</span>);</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">First_Choice_Hill_Climbing</span>(&amp;board);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the second cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">set_state</span>(<span class="string">&quot;45634565&quot;</span>);</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">First_Choice_Hill_Climbing</span>(&amp;board);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the third cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">random_initial_state</span>();</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">First_Choice_Hill_Climbing</span>(&amp;board);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">FCHC_test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Board board;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        board.<span class="built_in">initial</span>();</span><br><span class="line">        board.<span class="built_in">random_initial_state</span>();</span><br><span class="line">        board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        cout &lt;&lt; board.<span class="built_in">get_state</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">First_Choice_Hill_Climbing</span>(&amp;board);</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;First_Choice_Hill_Climbing: &quot;</span> &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Success Rate: &quot;</span> &lt;&lt; <span class="built_in">float</span>(count) / <span class="number">1000</span> &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;/1000]&quot;</span> &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Success average steps: &quot;</span> &lt;&lt; <span class="built_in">float</span>(FCHC_success_total_steps) / count &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Failed average steps: &quot;</span> &lt;&lt; <span class="built_in">float</span>(FCHC_failed_total_steps) / (<span class="number">1000</span> - count) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RRSHC_test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Board board;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the first cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">initial</span>();</span><br><span class="line">    board.<span class="built_in">set_state</span>(<span class="string">&quot;16471352&quot;</span>);</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Random_Restart_Steepest_Hill_Climbing</span>(&amp;board);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the second cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">set_state</span>(<span class="string">&quot;45634565&quot;</span>);</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Random_Restart_Steepest_Hill_Climbing</span>(&amp;board);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the third cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">random_initial_state</span>();</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">Random_Restart_Steepest_Hill_Climbing</span>(&amp;board);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RRSHC_test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Board board;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        board.<span class="built_in">initial</span>();</span><br><span class="line">        board.<span class="built_in">random_initial_state</span>();</span><br><span class="line">        board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        cout &lt;&lt; board.<span class="built_in">get_state</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Random_Restart_Steepest_Hill_Climbing</span>(&amp;board);</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">0</span>)) ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Random_Start_Steepest_Hill_Climbing: &quot;</span> &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Success Rate: &quot;</span> &lt;&lt; <span class="built_in">float</span>(count) / <span class="number">1000</span> &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;/1000]&quot;</span> &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Success average steps: &quot;</span> &lt;&lt; <span class="built_in">float</span>(RRSHC_success_total_steps) / count &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Failed average steps: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span> - count == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;never failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">float</span>(RRSHC_failed_total_steps) / (<span class="number">1000</span> - count) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">schedule</span><span class="params">(<span class="type">float</span> T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.9999</span> * T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SIMULATED-ANNEALING</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Simulated_Annealing</span><span class="params">(Board* board, <span class="type">float</span>(*p)(<span class="type">float</span>))</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> steps = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> T = <span class="number">5</span>;        <span class="comment">// 把初始温度设置为 5</span></span><br><span class="line">    string old_state = board-&gt;<span class="built_in">get_state</span>();</span><br><span class="line">    string new_state = old_state;</span><br><span class="line">    <span class="type">int</span> old_value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> new_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (T &gt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">        ++steps;</span><br><span class="line">        old_value = board-&gt;<span class="built_in">h_of_not_attack_pair</span>();</span><br><span class="line">        <span class="keyword">if</span> (board-&gt;<span class="built_in">check</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">            SA_success_total_steps += steps;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        T = (*p)(T);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机选择一个新的邻接状态</span></span><br><span class="line">        <span class="comment">// 随机抽取一个列</span></span><br><span class="line">        <span class="type">int</span> y = <span class="built_in">rand</span>() % <span class="number">8</span>;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 随机抽取该列中的 free 的行（也即没有皇后的行）</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            x = <span class="built_in">rand</span>() % <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">if</span> (x != old_state[y] - <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        new_state = old_state;</span><br><span class="line">        new_state[y] = x + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        board-&gt;<span class="built_in">set_state</span>(new_state);</span><br><span class="line">        board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">        new_value = board-&gt;<span class="built_in">h_of_not_attack_pair</span>();</span><br><span class="line">        <span class="type">int</span> deltaE = (new_value - old_value);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (deltaE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            old_state = new_state;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; deltaE &lt;&lt; &quot;: &quot; &lt;&lt; T &lt;&lt; &quot;:&quot; &lt;&lt; deltaE / T &lt;&lt; &quot; : &quot; &lt;&lt; exp(deltaE / T) &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((<span class="type">float</span>)(<span class="built_in">rand</span>() % <span class="number">1000</span>) / <span class="number">1000</span>) &lt; <span class="built_in">exp</span>(deltaE / T)) &#123;</span><br><span class="line">                old_state = new_state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                board-&gt;<span class="built_in">set_state</span>(old_state);</span><br><span class="line">                board-&gt;<span class="built_in">fill_in_board</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SA_failed_total_steps += steps;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SA_test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Board board;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the first cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">initial</span>();</span><br><span class="line">    board.<span class="built_in">set_state</span>(<span class="string">&quot;16471352&quot;</span>);</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Simulated_Annealing</span>(&amp;board, &amp;schedule);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the second cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">set_state</span>(<span class="string">&quot;45634565&quot;</span>);</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Simulated_Annealing</span>(&amp;board, &amp;schedule);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;For the third cases: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">random_initial_state</span>();</span><br><span class="line">    board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">Simulated_Annealing</span>(&amp;board, &amp;schedule);</span><br><span class="line">    <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">1</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Success&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    board.<span class="built_in">display</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SA_test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Board board;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        board.<span class="built_in">initial</span>();</span><br><span class="line">        board.<span class="built_in">random_initial_state</span>();</span><br><span class="line">        board.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; board.<span class="built_in">get_state</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">Simulated_Annealing</span>(&amp;board, schedule);</span><br><span class="line">        <span class="keyword">if</span> (board.<span class="built_in">check</span>(<span class="number">1</span>)) ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Simulated_Annealing_Hill_Climbing: &quot;</span> &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Success Rate: &quot;</span> &lt;&lt; <span class="built_in">float</span>(count) / <span class="number">1000</span> &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;/1000]&quot;</span> &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Success average steps: &quot;</span> &lt;&lt; <span class="built_in">float</span>(SA_success_total_steps) / count &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Failed average steps: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span> - count == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;never failed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="built_in">float</span>(SA_failed_total_steps) / (<span class="number">1000</span> - count) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// GENETIC-ALGORITHM</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Random_Selection</span><span class="params">(vector&lt;string&gt; &amp;p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> total_value = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">h</span><span class="params">(p.size())</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; rand_array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        b_tool.<span class="built_in">set_state</span>(p[i]);</span><br><span class="line">        b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        h[i] = b_tool.<span class="built_in">h_of_not_attack_pair</span>();</span><br><span class="line">        total_value += h[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; h[i]; ++j) &#123;</span><br><span class="line">            rand_array.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rv = <span class="built_in">rand</span>() % total_value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p[rand_array[rv]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Reproduce</span><span class="params">(string x, string y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cut = <span class="built_in">rand</span>() % <span class="number">5</span>;    <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    cut += <span class="number">2</span>;                <span class="comment">// 2 3 4 5 6</span></span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">substr</span>(<span class="number">0</span>, cut) + y.<span class="built_in">substr</span>(cut);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Mutate</span><span class="params">(string &amp;s, <span class="type">float</span> rate)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rand_mutate_pos = <span class="built_in">rand</span>() % <span class="number">64</span>;</span><br><span class="line">    string new_s = s;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> new_h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (((<span class="type">float</span>)(<span class="built_in">rand</span>() % <span class="number">1000</span>) / <span class="number">1000</span>) &lt; rate) &#123;</span><br><span class="line">        new_s[rand_mutate_pos / <span class="number">8</span>] = (rand_mutate_pos % <span class="number">8</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        b_tool.<span class="built_in">set_state</span>(new_s);</span><br><span class="line">        b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        new_h = b_tool.<span class="built_in">h_of_not_attack_pair</span>();</span><br><span class="line">        b_tool.<span class="built_in">set_state</span>(s);</span><br><span class="line">        b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        h = b_tool.<span class="built_in">h_of_not_attack_pair</span>();</span><br><span class="line">        <span class="keyword">if</span> (new_h &gt;= h) s = new_s;                        <span class="comment">// 为加快收敛速度，只保留有利变异</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_p</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> str : p) &#123;</span><br><span class="line">        b_tool.<span class="built_in">set_state</span>(str);</span><br><span class="line">        b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        cout &lt;&lt; str &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; b_tool.<span class="built_in">h_of_not_attack_pair</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Genetic_Algorithn</span><span class="params">(vector&lt;string&gt; &amp;p, <span class="type">float</span> mutate_rate)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; old_p = p;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">new_p</span><span class="params">(p.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; <span class="number">1000</span>; ++n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            string x = <span class="built_in">Random_Selection</span>(old_p);</span><br><span class="line">            string y = <span class="built_in">Random_Selection</span>(old_p);</span><br><span class="line">            string child = <span class="built_in">Reproduce</span>(x, y);</span><br><span class="line">            <span class="built_in">Mutate</span>(child, mutate_rate);</span><br><span class="line">            new_p[i] = child;</span><br><span class="line">            b_tool.<span class="built_in">set_state</span>(child);</span><br><span class="line">            b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">            <span class="keyword">if</span> (b_tool.<span class="built_in">check</span>(<span class="number">1</span>)) &#123;        <span class="comment">// 若成功找到解，输出到 p[0] 上</span></span><br><span class="line">                p[<span class="number">0</span>] = child;</span><br><span class="line">                generation += n;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        old_p = new_p;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl &lt;&lt; n + 1 &lt;&lt; &quot;:&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// print_p(old_p);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    p = old_p;                            <span class="comment">// 失败，但得到较好的种群</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GA_test1</span><span class="params">(<span class="type">int</span> p_size = <span class="number">4</span>, <span class="type">float</span> mutate_rate = <span class="number">0.5</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">p</span><span class="params">(p_size)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; p_size; ++i) &#123;</span><br><span class="line">        b_tool.<span class="built_in">random_initial_state</span>();</span><br><span class="line">        b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        p[i] = b_tool.<span class="built_in">get_state</span>();</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; b_tool.<span class="built_in">h_of_not_attack_pair</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Genetic_Algorithn</span>(p, mutate_rate)) &#123;</span><br><span class="line">        b_tool.<span class="built_in">set_state</span>(p[<span class="number">0</span>]);</span><br><span class="line">        b_tool.<span class="built_in">fill_in_board</span>();</span><br><span class="line">        b_tool.<span class="built_in">display</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GA_test2</span><span class="params">(<span class="type">int</span> p_size = <span class="number">4</span>, <span class="type">float</span> mutate_rate = <span class="number">0.5</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GA_test1</span>(p_size, mutate_rate)) ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Genetic_Algorithm: &quot;</span> &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Success Rate: &quot;</span> &lt;&lt; <span class="built_in">float</span>(count) / <span class="number">1000</span> &lt;&lt; <span class="string">&quot; [&quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;/1000]&quot;</span> &lt;&lt; endl</span><br><span class="line">        &lt;&lt; <span class="string">&quot;Success Average Generation: &quot;</span> &lt;&lt; <span class="built_in">float</span>(generation) / count &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SHC_test1();</span></span><br><span class="line">    <span class="comment">// SHC_test2();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// FCHC_test1();</span></span><br><span class="line">    <span class="comment">// FCHC_test2();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RRSHC_test1();</span></span><br><span class="line">    <span class="comment">// RRSHC_test2();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SA_test1();</span></span><br><span class="line">    <span class="comment">// SA_test2();</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// GA_test1();</span></span><br><span class="line">    <span class="comment">// GA_test2();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">RQTN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/ai/eight-queens/eight-queens/">http://example.com/ai/eight-queens/eight-queens/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">RQTN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/">八皇后问题</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/mit-18.06/mit-18.06-lec19/" title="Lec19 - 行列式公式和代数余子式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Lec19 - 行列式公式和代数余子式</div></div></a></div><div class="next-post pull-right"><a href="/princeton-algs4/03-ALGS4-Analysis-Of-Algorithms/" title="Analysis Of Algorithms"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Analysis Of Algorithms</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RQTN</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RQTN"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RQTN" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%88%AC%E5%B1%B1%E6%B3%95%E3%80%81%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E5%92%8C%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-text">使用爬山法、模拟退火和遗传算法求解八皇后问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5"><span class="toc-text">1. 准备阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Board-%E7%B1%BB"><span class="toc-text">1.1 Board 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%85%B6%E4%BB%96%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">1.2 其他全局变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%88%AC%E5%B1%B1%E6%B3%95"><span class="toc-text">2. 爬山法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%9C%80%E9%99%A1%E4%B8%8A%E5%8D%87%E7%88%AC%E5%B1%B1%E6%B3%95"><span class="toc-text">2.1 最陡上升爬山法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.1.1 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E6%B5%8B%E8%AF%95"><span class="toc-text">2.1.2 测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E9%A6%96%E9%80%89%E7%88%AC%E5%B1%B1%E6%B3%95"><span class="toc-text">2.2 首选爬山法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2.1 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E6%B5%8B%E8%AF%95"><span class="toc-text">2.2.2 测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%9A%8F%E6%9C%BA%E9%87%8D%E5%90%AF%E7%88%AC%E5%B1%B1%E6%B3%95"><span class="toc-text">2.3 随机重启爬山法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.1 代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-%E6%B5%8B%E8%AF%95"><span class="toc-text">2.3.2 测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB"><span class="toc-text">3. 模拟退火</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.1 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%B5%8B%E8%AF%95"><span class="toc-text">3.2 测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95"><span class="toc-text">4. 遗传算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.1 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B5%8B%E8%AF%95"><span class="toc-text">4.2 测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%80%9D%E8%80%83"><span class="toc-text">4.3 实现过程中遇到的问题与思考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81"><span class="toc-text">5. 完整代码</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-mysql/MVCC%20-%20undo%20log%20%E7%89%88%E6%9C%AC%E9%93%BE%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99/" title="MVCC - undo log 版本链数据访问规则">MVCC - undo log 版本链数据访问规则</a><time datetime="2023-06-27T14:19:24.000Z" title="发表于 2023-06-27 22:19:24">2023-06-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/synchronized%20%E5%8E%9F%E7%90%86/" title="synchronized 原理">synchronized 原理</a><time datetime="2023-05-04T09:46:08.000Z" title="发表于 2023-05-04 17:46:08">2023-05-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--重量级锁">好文收录 - 死磕Synchronized底层实现--重量级锁</a><time datetime="2023-04-27T17:00:08.000Z" title="发表于 2023-04-28 01:00:08">2023-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--轻量级锁">好文收录 - 死磕Synchronized底层实现--轻量级锁</a><time datetime="2023-04-26T17:00:08.000Z" title="发表于 2023-04-27 01:00:08">2023-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E5%81%8F%E5%90%91%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--偏向锁">好文收录 - 死磕Synchronized底层实现--偏向锁</a><time datetime="2023-04-25T17:00:08.000Z" title="发表于 2023-04-26 01:00:08">2023-04-26</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By RQTN</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://unpkg.com/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer="defer" id="ribbon" src="https://unpkg.com/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>