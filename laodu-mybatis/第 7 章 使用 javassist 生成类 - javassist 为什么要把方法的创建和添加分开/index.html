<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>使用 javassist 生成类 - javassist 为什么要把方法的创建和添加分开 | RQTN</title><meta name="author" content="RQTN"><meta name="copyright" content="RQTN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="使用 javassist 生成类 - javassist 为什么要把方法的创建和添加分开先来看如下代码： 123456789101112131415@Testpublic void testGenerateFirstClass() throws Exception &#123;    &#x2F;&#x2F; 获取类池，类池有两个主要用途：(1) 获取已知类 (2) 制造新类    ClassPool pool &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="使用 javassist 生成类 - javassist 为什么要把方法的创建和添加分开">
<meta property="og:url" content="http://example.com/laodu-mybatis/%E7%AC%AC%207%20%E7%AB%A0%20%E4%BD%BF%E7%94%A8%20javassist%20%E7%94%9F%E6%88%90%E7%B1%BB%20-%20javassist%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%88%86%E5%BC%80/index.html">
<meta property="og:site_name" content="RQTN">
<meta property="og:description" content="使用 javassist 生成类 - javassist 为什么要把方法的创建和添加分开先来看如下代码： 123456789101112131415@Testpublic void testGenerateFirstClass() throws Exception &#123;    &#x2F;&#x2F; 获取类池，类池有两个主要用途：(1) 获取已知类 (2) 制造新类    ClassPool pool &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2022-10-19T02:49:54.000Z">
<meta property="article:modified_time" content="2024-04-01T01:47:42.977Z">
<meta property="article:author" content="RQTN">
<meta property="article:tag" content="laodu-mybatis">
<meta property="article:tag" content="javassist">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/laodu-mybatis/%E7%AC%AC%207%20%E7%AB%A0%20%E4%BD%BF%E7%94%A8%20javassist%20%E7%94%9F%E6%88%90%E7%B1%BB%20-%20javassist%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%88%86%E5%BC%80/index.html"><link rel="preconnect" href="//unpkg.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: RQTN","link":"链接: ","source":"来源: RQTN","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://unpkg.com/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '使用 javassist 生成类 - javassist 为什么要把方法的创建和添加分开',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-01 09:47:42'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index_img_cut.png')"><nav id="nav"><span id="blog-info"><a href="/" title="RQTN"><span class="site-name">RQTN</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">使用 javassist 生成类 - javassist 为什么要把方法的创建和添加分开</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-10-19T02:49:54.000Z" title="发表于 2022-10-19 10:49:54">2022-10-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/Mybatis/">Mybatis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>11分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="使用 javassist 生成类 - javassist 为什么要把方法的创建和添加分开"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="使用-javassist-生成类-javassist-为什么要把方法的创建和添加分开"><a href="#使用-javassist-生成类-javassist-为什么要把方法的创建和添加分开" class="headerlink" title="使用 javassist 生成类 - javassist 为什么要把方法的创建和添加分开"></a>使用 javassist 生成类 - javassist 为什么要把方法的创建和添加分开</h2><p>先来看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenerateFirstClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 获取类池，类池有两个主要用途：(1) 获取已知类 (2) 制造新类</span></span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="comment">// 制造新类，需要提供全类名</span></span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.powernode.bank.dao.impl.AccountDaoImpl&quot;</span>);</span><br><span class="line">    <span class="comment">// 制造方法，第一个参数是方法代码字符串，第二个参数是该方法所属的类</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodCode</span> <span class="operator">=</span> <span class="string">&quot;public void insert() &#123; System.out.println(123); &#125;&quot;</span>;</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtMethod.make(methodCode, ctClass);</span><br><span class="line">    <span class="comment">// 将方法添加到类中，这一步是必需的</span></span><br><span class="line">    ctClass.addMethod(ctMethod);</span><br><span class="line">    <span class="comment">// 在内存中生成 Class：生成制造类的字节码，并将类字节码装载到 JVM 中，初始化该类，</span></span><br><span class="line">    <span class="comment">// 完成静态代码块和静态字段的初始化，最后返回 JVM 中对应的 Class 对象</span></span><br><span class="line">    Class&lt;?&gt; tmp = ctClass.toClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要看其中的这两行代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CtMethod</span> <span class="variable">ctMethod</span> <span class="operator">=</span> CtMethod.make(methodCode, ctClass);</span><br><span class="line">ctClass.addMethod(ctMethod);</span><br></pre></td></tr></table></figure>
<p>我的疑惑是，既然在制造方法的时候，就需要提供 <code>ctClass</code>，那后面的 <code>ctClass.addMethod(ctMethod)</code> 为什么不直接写到 <code>CtMethod.make</code> 方法中呢？</p>
<p>网上基本找不到相关的问题，问 ChatGPT / New Bing / Glaude 给我的回复大都是：</p>
<ul>
<li>分开更灵活，通过分离这些步骤，开发人员可以在将方法最终添加到类之前，根据需要对其执行额外的修改。</li>
</ul>
<p>这样的说法看起来很有道理，但是一测试就发现：方法 <code>ctMethod</code> 添加到 <code>ctClass</code> 以后，仍然可以对 <code>ctMethod</code> 进行修改操作。这样的话，所谓的更灵活的说法就没有说服力了。</p>
<hr>
<p>在研究这个问题前，这里先做三个测试，通过测试来了解创建方法和添加方法的一些细节：</p>
<p>测试一：<code>CtMethod.make(&quot;method_code&quot;, ctClass)</code> 制造出的方法 <code>ctMethod</code> 会与 <code>ctClass</code> 建立关联，后续 <code>ctMethod</code> 只能被添加到 <code>ctClass</code> 中，而不能添加到其他类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOtherCtMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClassA</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.powernode.pojo.A&quot;</span>);</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClassB</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.powernode.pojo.B&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctMethodForA</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func1() &#123; System.out.println(\&quot;func1\&quot;); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    <span class="comment">// 将 ctMethodForA 方法添加到 ctClassA 中</span></span><br><span class="line">    ctClassA.addMethod(ctMethodForA);</span><br><span class="line">    <span class="comment">// 将 ctMethodForA 方法添加到 ctClassB 中</span></span><br><span class="line">    <span class="comment">// 抛出异常：javassist.CannotCompileException: bad declaring class</span></span><br><span class="line">    ctClassB.addMethod(ctMethodForA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试二：<code>ctClass.addMethod(ctMethod)</code> 是必需的，这一步才是真正将方法 <code>ctMethod</code> 添加到类 <code>ctClass</code> 中，<code>CtMethod.make</code> 只是建立了二者的关联，但并没有真正的添加。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDoNotAddMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClassA</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.powernode.pojo.A&quot;</span>);</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctMethodForA</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func1() &#123; System.out.println(\&quot;func1\&quot;); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    <span class="comment">// 不添加方法到类中</span></span><br><span class="line"><span class="comment">//    ctClassA.addMethod(ctMethodForA);</span></span><br><span class="line">    Class&lt;?&gt; clazzA = ctClassA.toClass();</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> clazzA.getDeclaredConstructor().newInstance();</span><br><span class="line">    <span class="comment">// 抛出异常 找不到方法：java.lang.NoSuchMethodException: com.powernode.pojo.A.func1()</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">func1</span> <span class="operator">=</span> clazzA.getDeclaredMethod(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line">    func1.invoke(objA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试三：<code>ctClass.addMethod(ctMethod)</code> 会进行检查 <code>ctMethod</code> 是否能够添加到 <code>ctClass</code> 中！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddConflictMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClassA</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.powernode.pojo.A&quot;</span>);</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctFunc1</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func1() &#123; System.out.println(\&quot;func1\&quot;); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    ctClassA.addMethod(ctFunc1);</span><br><span class="line">    <span class="comment">// 依然可以创建同名 func1 方法并与 ctClassA 关联</span></span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctStillFunc1</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func1() &#123; System.out.println(\&quot;still func1\&quot;); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    <span class="comment">// 但在添加时，会检查到重复方法</span></span><br><span class="line">    <span class="comment">// 抛出异常：javassist.bytecode.DuplicateMemberException: duplicate method: func1 in com.powernode.pojo.A</span></span><br><span class="line">    ctClassA.addMethod(ctStillFunc1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上三个测试，我们清楚了：</p>
<ul>
<li><code>CtMethod ctMethod = CtMethod.make(methodCode, ctClass)</code> 只是建立了 <code>ctMethod</code> 和 <code>ctClass</code> 的关联，并没有将 <code>ctMethod</code> 添加到 <code>ctClass</code> 中。 </li>
<li><code>ctClass.addMethod(ctMethod)</code> 是必需的，这一步会检查 <code>ctMethod</code> 是否能够添加到 <code>ctClass</code> 中，如果可以，才真正将 <code>ctMethod</code> 添加到 <code>ctClass</code> 中。</li>
</ul>
<hr>
<p>下面我们再看两个测试，这两个测试聚焦于方法的修改操作，探究修改方法会带来什么影响：</p>
<p>测试四：下面将两个不同名的方法添加到类中，然后修改其中一个方法的方法名，使其与另外一个方法保持同名，修改操作不会立刻抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testModifyMethodToConflict</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClassA</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.powernode.pojo.A&quot;</span>);</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctFunc1</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func1() &#123; System.out.println(\&quot;func1\&quot;); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    ctClassA.addMethod(ctFunc1);</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctFunc2</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func2() &#123; System.out.println(\&quot;func2\&quot;); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    ctClassA.addMethod(ctFunc2);</span><br><span class="line"></span><br><span class="line">    ctFunc2.setName(<span class="string">&quot;func1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛出异常 编译失败：javassist.CannotCompileException: by java.lang.reflect.InvocationTargetException</span></span><br><span class="line">    <span class="comment">// 查看异常堆栈 检查到了重复方法名：Caused by: java.lang.ClassFormatError: Duplicate method name &quot;func1&quot; with signature &quot;()V&quot; in class file com/powernode/pojo/A</span></span><br><span class="line">    Class&lt;?&gt; clazzA = ctClassA.toClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，相比测试三而言，测试四的重复方法异常要等到生成类 <code>ctClassA.toClass()</code> 才会暴露出来。</p>
<p>测试五：下面包含两个方法，其中一个方法 <code>ctFunc2</code> 内部调用了另外一个方法 <code>ctFunc1</code>，在两个方法都添加到类中以后，修改被调用方法 <code>ctFunc1</code> 的函数名，修改操作不会立刻抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethodCallOtherMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClassA</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.powernode.pojo.A&quot;</span>);</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctFunc1</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func1() &#123; System.out.println(\&quot;func1\&quot;); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    ctClassA.addMethod(ctFunc1);</span><br><span class="line">    <span class="comment">// 制造方法时，会利用传入的 ctClassA 检查要调用的 func1() 是否已存在</span></span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctFunc2</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func2() &#123; func1(); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    ctClassA.addMethod(ctFunc2);</span><br><span class="line"></span><br><span class="line">    ctFunc1.setName(<span class="string">&quot;func123&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; clazzA = ctClassA.toClass();</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> clazzA.getDeclaredConstructor().newInstance();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">func2</span> <span class="operator">=</span> clazzA.getDeclaredMethod(<span class="string">&quot;func2&quot;</span>);</span><br><span class="line">    <span class="comment">// 抛出异常 调用异常：java.lang.reflect.InvocationTargetException</span></span><br><span class="line">	<span class="comment">// 查看异常堆栈 找不到方法：Caused by: java.lang.NoSuchMethodError: &#x27;void com.powernode.pojo.A.func1()&#x27;</span></span><br><span class="line">    func2.invoke(objA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，相比测试四而言，测试五的异常要等到方法调用执行时 <code>func2.invoke(objA)</code> 才会暴露出来。</p>
<p>这里诡异的是，异常居然没有在生成类的时候就发现！<br>如果我们将这个要制造的类写成代码，那么在 <code>ctClassA.toClass()</code> 之前，其内容应该如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.powernode.pojo.A;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func123</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;func1&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">        func1();    <span class="comment">// 这一行编译就应该报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显这样的代码不应该能够通过编译，可是在生成类 <code>ctClassA.toClass()</code> 的时候却没有抛出异常！</p>
<p>通过测试四和测试五，不难意识到：虽然 javassist 允许方法被添加到类中以后仍然可以进行修改，但是这样做，可能会带来各种各样奇怪的问题。</p>
<p>最佳实践是：创建方法且修改方法完毕后，再将方法添加到类中，且方法一旦添加到类中后，就不要进行修改！</p>
<p>另外，注意在创建方法 <code>ctFun2</code> 的时候，由于 <code>ctFun2</code> 的方法体中调用了 <code>fun1</code>，因此在创建时，<code>CtMethod.make(&quot;...&quot;, ctClassA)</code> 方法其实会检查 <code>ctClassA</code> 中是否已经定义了 <code>fun1</code>，这里反映出传 <code>ctClassA</code> 作为第二个参数的另外一个作用，检查新添加到类中的方法是否合法。</p>
<hr>
<p>上面的测试四和测试五中，我们在方法添加到类中后，又对方法进行了修改，但修改方法的位置却没有立刻报错。</p>
<p>猜测，是不是修改方法，本身不会做任何检查呢？其实并不是所有修改方法，都不做任何检查，比如 <code>setBody</code> 方法，底层会进行方法体的编译检查！</p>
<p>测试六：创建方法后，修改方法体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testModifyMethodBody</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClassA</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.powernode.pojo.A&quot;</span>);</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctFunc1</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func1() &#123; System.out.println(\&quot;func1\&quot;); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    ctClassA.addMethod(ctFunc1);</span><br><span class="line">    <span class="comment">// 制造方法时，会利用 ctClassA 检查 func1 是否已存在</span></span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctFunc2</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func2() &#123; func1(); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    <span class="comment">// 修改方法体，调用一个不存在的方法</span></span><br><span class="line">    <span class="comment">// 抛出编译异常：javassist.CannotCompileException: [source error] func3() not found in com.powernode.pojo.A</span></span><br><span class="line">    ctFunc2.setBody(<span class="string">&quot;&#123; func3(); &#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 <code>setName</code> 方法，底层似乎确实没做任何检查，甚至连标识符命名的检查都没有。</p>
<p>测试七：故意为方法设置了不满足 Java 标识符命名规则的方法名，但却可以正常调用执行！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethodName</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> ClassPool.getDefault();</span><br><span class="line">    <span class="type">CtClass</span> <span class="variable">ctClassA</span> <span class="operator">=</span> pool.makeClass(<span class="string">&quot;com.powernode.pojo.A&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建方法时会检查方法名的标识符命名是否满足要求，底层 javassist 进行了编译</span></span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">ctFunc1</span> <span class="operator">=</span> CtMethod.make(<span class="string">&quot;public void func1() &#123; System.out.println(\&quot;func1\&quot;); &#125;&quot;</span>, ctClassA);</span><br><span class="line">    ctFunc1.setName(<span class="string">&quot;####&quot;</span>);</span><br><span class="line">    ctClassA.addMethod(ctFunc1);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazzA = ctClassA.toClass();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">objA</span> <span class="operator">=</span> clazzA.getDeclaredConstructor().newInstance();</span><br><span class="line">    <span class="type">Method</span> <span class="variable">badName</span> <span class="operator">=</span> clazzA.getDeclaredMethod(<span class="string">&quot;####&quot;</span>);</span><br><span class="line">    <span class="comment">// 正常调用，输出 &quot;func1&quot;</span></span><br><span class="line">    badName.invoke(objA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>javassist 中在 <code>CtMethod.make</code> 时会检查方法名的标识符命名是否满足要求，但可以通过 <code>setName</code> 绕过。</p>
<hr>
<p>现在回到最初的问题，为什么 javassist 要把方法的创建和方法的添加分两步实现？为什么不在 <code>CtMethod.make</code> 中把 <code>ctClass.addMethod(ctMethod)</code> 干脆也一并做了呢？</p>
<p>最直观地，通过测试四和测试五以后，不难发现，如果创建方法的同时就将方法添加到类中，以后就不好再去修改方法了：</p>
<ul>
<li>如果要修改的话，虽然允许修改，但是一旦修改就违反了最佳实践，可能带来各种奇奇怪怪的问题</li>
<li>如果不修改的话，又意味着在创建方法的时候，要一次性把方法全部准备好，这就牺牲了很多的灵活性。</li>
</ul>
<p>此外分步实现的话，代码可读性可维护性也更好，方法的完整定义肯定是包裹在方法的创建和方法的添加之间的，作用域相对明确。</p>
<p>这是较浅层次的理解，我认为更深层次的原因其实是设计上的考虑。</p>
<p>类是一个比较复杂的东西，每次做的修改可能会导致整个类最后出问题。<br>为了尽可能保证正确性，那么每一步的修改，都一定是要经过最严格的检查，才正式添加到类中。<br>这样的话，类虽然一步一步地变复杂，但是在每个时刻是完整且正确的。<br>另外，修改频率也应该尽可能低，一方面是少改少错，另一方面即使存在完美的检查允许高频修改，那么完美检查的代价也是不容忽视的。</p>
<p>javassist 既然是在制造类，那么肯定也会有如上的设计考虑。</p>
<p>方法正式添加到类中，这是一种对类的修改，所以它需要做最严格的检查，确保不会对类整体带来影响。<br>同时也需要保证类的完整性和修改频率尽可能低。如何保证？很自然地，让方法的创建和修改彻底完成后，再进行方法的添加！因此，要把方法的创建与修改，和方法添加到类中分开。</p>
<p>方法的创建与修改，是圈地自萌的小打小闹，发生频率较高，我们可以额外做一些部分的更聚焦于当前方法自身的小检查来保证方法的基本正确性。由于小检查的代价较低，所以即便修改频率较高，也不会带来太大的性能影响。</p>
<p>方法添加到类中，是正式走上台面的团队协作，我们必须做一些方法到类整体上的大检查。虽然大检查的代价较高，但是添加只做一次，是低频的，所以可以接收。</p>
<p>这样划分步骤以后，能够保证类是一步一步地变复杂，但每个时刻是完整且正确的。</p>
<p>试想一下，如果方法的创建与添加真的合并在一起了：由于方法已经在类中，此时每次修改操作，显然就都要做最严格的的检查了，这肯定至少在性能上有影响；如果没有做最严格的的操作，那就不能保证类整体的正确性。<br>另外，方法的修改可能是分多步进行的，这就意味着某个时刻的类，可能正处于修改的某一步，类不是完整的，这样也会带来很多设计上的复杂性，比如说可能检查需要考虑更多的东西。</p>
<p>其实，这样的设计思路在我们日常开发过程中也可以体现出来。<br>方法的创建与修改就类似于本地开发一个新模块，最多我们自己写一些单元测试测一测，保证基本是没什么问题的。<br>方法添加到类中，就类似于将本地的新模块放到整个系统中，此时肯定需要更系统的测试，确保没问题后，再正式上线。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">RQTN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/laodu-mybatis/%E7%AC%AC%207%20%E7%AB%A0%20%E4%BD%BF%E7%94%A8%20javassist%20%E7%94%9F%E6%88%90%E7%B1%BB%20-%20javassist%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%88%86%E5%BC%80/">http://example.com/laodu-mybatis/%E7%AC%AC%207%20%E7%AB%A0%20%E4%BD%BF%E7%94%A8%20javassist%20%E7%94%9F%E6%88%90%E7%B1%BB%20-%20javassist%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%88%86%E5%BC%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">RQTN</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/laodu-mybatis/">laodu-mybatis</a><a class="post-meta__tags" href="/tags/javassist/">javassist</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/laodu-mybatis/%E7%AC%AC%205%20%E7%AB%A0%20%E6%89%8B%E5%86%99%20MyBatis%20%E6%A1%86%E6%9E%B6%20-%20GodBatis%20%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%94%B9%E8%BF%9B/" title="手写 MyBatis 框架 - GodBatis 实现上的问题与改进"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">手写 MyBatis 框架 - GodBatis 实现上的问题与改进</div></div></a></div><div class="next-post pull-right"><a href="/laodu-mybatis/%E7%AC%AC%208%20%E7%AB%A0%20MyBatis%20%E4%B8%AD%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BD%BF%E7%94%A8%20-%20sqlSession.getMapper()%20%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/" title="MyBatis 中接口代理机制及使用 - sqlSession.getMapper() 的使用问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MyBatis 中接口代理机制及使用 - sqlSession.getMapper() 的使用问题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/laodu-mybatis/%E7%AC%AC%205%20%E7%AB%A0%20%E6%89%8B%E5%86%99%20MyBatis%20%E6%A1%86%E6%9E%B6%20-%20GodBatis%20%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%94%B9%E8%BF%9B/" title="手写 MyBatis 框架 - GodBatis 实现上的问题与改进"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-17</div><div class="title">手写 MyBatis 框架 - GodBatis 实现上的问题与改进</div></div></a></div><div><a href="/laodu-mybatis/%E7%AC%AC%204%20%E7%AB%A0%20Mybatis%20%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%20-%20%E6%95%B0%E6%8D%AE%E6%BA%90%20JNDI%20%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/" title="Mybatis 核心配置文件 - 数据源 JNDI 集成第三方数据库连接池"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-14</div><div class="title">Mybatis 核心配置文件 - 数据源 JNDI 集成第三方数据库连接池</div></div></a></div><div><a href="/laodu-mybatis/%E7%AC%AC%208%20%E7%AB%A0%20MyBatis%20%E4%B8%AD%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E5%8F%8A%E4%BD%BF%E7%94%A8%20-%20sqlSession.getMapper()%20%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/" title="MyBatis 中接口代理机制及使用 - sqlSession.getMapper() 的使用问题"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-22</div><div class="title">MyBatis 中接口代理机制及使用 - sqlSession.getMapper() 的使用问题</div></div></a></div><div><a href="/laodu-mybatis/%E7%AC%AC%2010%20%E7%AB%A0%20MyBatis%20%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%20-%20%E6%8E%A5%E5%8F%A3%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" title="MyBatis 参数处理 - 接口代理机制源码分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-26</div><div class="title">MyBatis 参数处理 - 接口代理机制源码分析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">RQTN</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/RQTN"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/RQTN" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-javassist-%E7%94%9F%E6%88%90%E7%B1%BB-javassist-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%B7%BB%E5%8A%A0%E5%88%86%E5%BC%80"><span class="toc-number">1.</span> <span class="toc-text">使用 javassist 生成类 - javassist 为什么要把方法的创建和添加分开</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-mysql/MVCC%20-%20undo%20log%20%E7%89%88%E6%9C%AC%E9%93%BE%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E8%A7%84%E5%88%99/" title="MVCC - undo log 版本链数据访问规则">MVCC - undo log 版本链数据访问规则</a><time datetime="2023-06-27T14:19:24.000Z" title="发表于 2023-06-27 22:19:24">2023-06-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/synchronized%20%E5%8E%9F%E7%90%86/" title="synchronized 原理">synchronized 原理</a><time datetime="2023-05-04T09:46:08.000Z" title="发表于 2023-05-04 17:46:08">2023-05-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--重量级锁">好文收录 - 死磕Synchronized底层实现--重量级锁</a><time datetime="2023-04-27T17:00:08.000Z" title="发表于 2023-04-28 01:00:08">2023-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--轻量级锁">好文收录 - 死磕Synchronized底层实现--轻量级锁</a><time datetime="2023-04-26T17:00:08.000Z" title="发表于 2023-04-27 01:00:08">2023-04-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/itheima-juc/%E5%A5%BD%E6%96%87%E6%94%B6%E5%BD%95-%E6%AD%BB%E7%A3%95Synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0--%E5%81%8F%E5%90%91%E9%94%81/" title="好文收录 - 死磕Synchronized底层实现--偏向锁">好文收录 - 死磕Synchronized底层实现--偏向锁</a><time datetime="2023-04-25T17:00:08.000Z" title="发表于 2023-04-26 01:00:08">2023-04-26</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347)"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By RQTN</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://unpkg.com/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="https://unpkg.com/butterfly-extsrc@1.1.3/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>